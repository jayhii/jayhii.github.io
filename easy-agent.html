<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Easy-Agent 에디터</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- 외부 라이브러리 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/drawflow/dist/drawflow.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastify-js/1.12.0/toastify.min.css">
  
  <style>
    :root {
      --primary-color: #2196F3;
      --primary-dark: #1565C0;
      --secondary-color: #4CAF50;
      --secondary-dark: #388E3C;
      --background-light: #f5f5f5;
      --border-color: #ccc;
      --shadow-color: rgba(0, 0, 0, 0.1);
    }

    html, body { 
      margin: 0; 
      padding: 0; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    .main-container {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    
    /* 헤더 스타일 */
    header {
      background-color: var(--primary-color);
      color: white;
      padding: 0.8rem 0;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      z-index: 100;
    }
    
    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 2rem;
    }
    
    .logo {
      font-size: 1.5rem;
      font-weight: bold;
      text-decoration: none;
      color: white;
      display: flex;
      align-items: center;
    }
    
    .logo-icon {
      margin-right: 10px;
      font-size: 1.8rem;
    }
    
    .page-title {
      font-size: 1.4rem;
      font-weight: 500;
    }
    
    .nav-buttons {
      display: flex;
      gap: 1rem;
      align-items: center;
    }
    
    .nav-button {
      background-color: rgba(255, 255, 255, 0.2);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background-color 0.3s;
      text-decoration: none;
      display: flex;
      align-items: center;
    }
    
    .nav-button:hover {
      background-color: rgba(255, 255, 255, 0.3);
    }
    
    .nav-button i {
      margin-right: 5px;
    }
    
    .user-profile {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: white;
      font-size: 0.9rem;
    }
    
    .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background-color: #fff;
      color: var(--primary-color);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }
    
    /* 워크스페이스 컨테이너 */
    .workspace-container { 
      display: flex; 
      flex: 1;
      height: calc(100vh - 128px); /* 헤더와 푸터 높이 제외 */
      width: 100vw; 
    }
    
    /* 사이드바 */
    .sidebar {
      width: 240px;
      background: var(--background-light);
      border-right: 1px solid var(--border-color);
      padding: 1rem;
      overflow-y: auto;
      box-shadow: 2px 0 5px var(--shadow-color);
      z-index: 10;
    }
    
    .sidebar h3 {
      margin-top: 0;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .sidebar button {
      width: 100%;
      padding: 1rem;
      margin-bottom: 12px;
      font-size: 1.1rem;
      background: #fff;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .sidebar button:hover {
      background: #e9f5ff;
      border-color: var(--primary-color);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px var(--shadow-color);
    }
    
    .sidebar button:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px var(--shadow-color);
    }
    
    .sidebar button::after {
      content: "+";
      font-size: 1.2rem;
      color: var(--primary-color);
    }

    /* 에디터 영역 */
    .editor-container {
      flex: 2;
      position: relative;
      display: flex;
      background-color: #fafafa;
    }
    
    .editor-background {
      width: 100%;
      height: 100%;
      background-image: radial-gradient(#ddd 1px, transparent 1px);
      background-size: 20px 20px;
    }

    /* 코드 뷰어 */
    .code-viewer {
      width: 30%;
      background: #fff;
      border-left: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      box-shadow: -2px 0 5px var(--shadow-color);
    }
    
    .code-viewer-content, .code-viewer-edit {
      padding: 1rem;
      
    }

    .code-viewer-content {
      flex: none; 
      height: 500px;
      display: flex;
      flex-direction: column;
    }    

    .code-viewer-edit {
      flex: none; 
      height: 420px; 
      background: #fff;
      border-top: 1px solid var(--border-color);
      overflow-y: auto;
    }

    .code-viewer-edit h4 { 
      margin-top: 0; 
      color: var(--primary-dark);
    }
    
    .code-viewer-edit label {
      display: block;
      margin-top: 12px;
      font-weight: 500;
    }
    
    .code-viewer-edit input, .code-viewer-edit textarea {
      width: 100%;
      margin-top: 5px;
      padding: 8px;
      box-sizing: border-box;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-family: inherit;
    }
    
    .code-viewer-edit textarea {
      min-height: 80px;
      resize: vertical;
    }
    
    .code-viewer-edit input:focus, .code-viewer-edit textarea:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
    }
    
    .code-viewer-edit button {
      margin-top: 15px;
      padding: 8px 12px;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    .code-viewer-edit button:hover {
      background-color: var(--primary-dark);
    }
    
    .code-viewer-content h3 {
      margin-top: 0;
      color: var(--primary-dark);
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .code-viewer-actions {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    
    .code-viewer-actions button {
      flex: 1;
      padding: 8px 12px;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    .code-viewer-actions button:hover {
      background-color: var(--primary-dark);
    }
    
    .code-viewer-actions button.secondary {
      background-color: #f5f5f5;
      color: #333;
      border: 1px solid var(--border-color);
    }
    
    .code-viewer-actions button.secondary:hover {
      background-color: #e0e0e0;
    }
    
    pre {
      flex: 1;
      max-height: 100%;
      background: #f8f8f8;
      padding: 1rem;
      border-radius: 6px;
      border: 1px solid #e0e0e0;
      white-space: pre-wrap;
      overflow-x: auto;
      overflow-y: auto;
      margin: 0;
    }

    /* 노드 스타일 */
    .drawflow {
      width: 70%;      
    }

    .drawflow .drawflow-node {
      background: white;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      box-shadow: 0 2px 10px var(--shadow-color);
      padding: 10px 15px;
      transition: box-shadow 0.3s, transform 0.3s;
    }
    
    .drawflow .drawflow-node:hover {
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      transform: translateY(-2px);
    }
    
    .drawflow .drawflow-node.selected {
      border: 2px solid var(--primary-color);
      box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.2);
    }
    
    .drawflow .drawflow-node .title-box {
      padding-bottom: 5px;
      margin-bottom: 5px;
      border-bottom: 1px solid var(--border-color);
      font-weight: bold;
      color: var(--primary-dark);
    }
    
    .drawflow .drawflow-node .description-box {
      font-size: 0.9rem;
      color: #666;
    }

    /* 특수 노드 스타일 */
    .drawflow .drawflow-node.Start {
      background-color: #e8f5e9;
      border-color: var(--secondary-color);
    }
    
    .drawflow .drawflow-node.End {
      background-color: #ffebee;
      border-color: #f44336;
    }
    
    .drawflow .drawflow-node.LLM {
      background-color: #e3f2fd;
    }
    
    .drawflow .drawflow-node.Tool {
      background-color: #fff3e0;
    }
    
    .drawflow .drawflow-node.Condition {
      background-color: #f3e5f5;
    }

    /* 연결선 스타일 */
    .drawflow .connection .main-path {
      stroke: var(--primary-color);
      stroke-width: 3px;
      fill: none;
      transition: stroke 0.3s ease;
    }
    
    .drawflow .connection:hover .main-path {
      stroke: var(--primary-dark);
      stroke-width: 4px;
    }
    
    .drawflow .connection.condition-connection .main-path {
      stroke: var(--secondary-color);
      stroke-dasharray: 5, 5;
    }
    
    .drawflow .connection.condition-connection:hover .main-path {
      stroke: var(--secondary-dark);
    }
    
    .drawflow .connection.selected .main-path {
      stroke: var(--primary-dark);
      stroke-width: 4px;
    }
    
    /* 툴팁 스타일 */
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 0.8rem;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    /* 모달 스타일 */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    
    .modal-content {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      width: 80%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .modal-header h2 {
      margin: 0;
    }
    
    .close-button {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
    }
    
    /* 로딩 스피너 */
    .spinner {
      border: 4px solid rgba(0, 0, 0, 0.1);
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border-left-color: var(--primary-color);
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .connection.condition-connection .main-path {
      stroke: var(--branch-color, var(--secondary-color));
      stroke-dasharray: 5, 5;
    }

    .connection.condition-connection:hover .main-path {
      stroke: var(--branch-color, var(--secondary-dark));
      stroke-width: 4px;
    }

    .branch-item {
      margin-bottom: 8px;
      animation: fadeIn 0.3s;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* 푸터 스타일 */
    footer {
      background-color: #333;
      color: white;
      padding: 1rem 0;
      font-size: 0.9rem;
    }
    
    .footer-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 2rem;
    }
    
    .footer-links {
      display: flex;
      gap: 1.5rem;
    }
    
    .footer-links a {
      color: #bbb;
      text-decoration: none;
      transition: color 0.3s;
    }
    
    .footer-links a:hover {
      color: white;
    }

    /* 반응형 디자인 */
    @media (max-width: 1200px) {
      .workspace-container {
        flex-direction: column;
        height: auto;
      }
      
      .sidebar {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid var(--border-color);
      }
      
      .code-viewer {
        width: 100%;
        border-left: none;
        border-top: 1px solid var(--border-color);
      }
    }
    
    @media (max-width: 768px) {
      .header-container {
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      
      .page-title {
        font-size: 1.2rem;
        flex-basis: 100%;
        text-align: center;
        margin: 0.5rem 0;
      }
      
      .footer-container {
        flex-direction: column;
        gap: 1rem;
        text-align: center;
      }
    }
  </style>
</head>

<body>
<div class="main-container">
  <!-- 헤더 -->
  <header>
    <div class="header-container">
      <a href="index.html" class="logo">
        <span class="logo-icon">🔄</span>
        EasyAgent
      </a>
      
      <div class="page-title">노드 에디터</div>
      
      <div class="nav-buttons">
        <a href="index.html" class="nav-button">
          <i>←</i> 메인으로
        </a>
        <a href="#" class="nav-button" id="saveWorkflowBtn">
          <i>💾</i> 저장
        </a>
        <div class="user-profile">
          <div class="user-avatar">G</div>
          <span>Guest</span>
        </div>
      </div>
    </div>
  </header>

  <div class="workspace-container">
    <!-- 사이드바 -->
    <div class="sidebar">
      <h3>Node 블록</h3>
      <div id="nodeButtons">
        <button data-type="Start" title="그래프 시작점">Start</button>
        <button data-type="End" title="그래프 종료점">End</button>
        <button data-type="LLM" title="언어 모델 호출">LLM</button>
        <button data-type="Tool" title="외부 도구 호출">Tool</button>
        <button data-type="Condition" title="조건 분기">Condition</button>
        <button data-type="Output" title="결과 출력">Output</button>
        <button data-type="Custom" title="사용자 정의 코드">Custom</button>
      </div>
      
      <div class="sidebar-actions" style="margin-top: 20px;">
        <button id="clearButton" style="background-color: #f44336; color: white;" title="모든 노드 삭제">
          Clear All
        </button>
        <button id="importButton" style="background-color: #4CAF50; color: white; margin-top: 10px;" title="JSON 파일 가져오기">
          Import JSON
        </button>
        <input type="file" id="importInput" style="display: none;" accept=".json">
        <button id="helpButton" style="background-color: #2196F3; color: white;" title="도움말 보기">
          도움말
        </button>
      </div>
    </div>

    <!-- 에디터 -->
    <div class="editor-container">
      <div id="drawflow" class="editor-background"></div>
      
      <!-- 툴팁 -->
      <div id="tooltip" class="tooltip"></div>
    </div>

    <!-- 코드 뷰어 -->
    <div class="code-viewer">
      <div id="formPopup" class="code-viewer-edit">
        <h4>노드 속성</h4>
        <div id="formFields">
          <p>편집할 노드를 선택하세요</p>
        </div>
      </div>

      <div class="code-viewer-content">
        <h3>생성된 Python 코드</h3>
        <pre id="codeOutput" class="language-python"># 블록을 추가해보세요</pre>
        <div class="code-viewer-actions">
          <button onclick="exportJson()">JSON 저장</button>
          <button onclick="copyCode()" class="secondary">코드 복사</button>
          <button onclick="previewExecution()" class="primary" style="background-color: #9C27B0;">실행 미리보기</button>
        </div>
      </div>
    </div>
  </div>

  <!-- 푸터 -->
  <footer>
    <div class="footer-container">
      <div class="copyright">
        &copy; 2025 EasyGen. All rights reserved.
      </div>
      <div class="footer-links">
        <a href="index.html">홈</a>
        <a href="#">문서</a>
        <a href="#">튜토리얼</a>
        <a href="#">API 참조</a>
        <a href="#">커뮤니티</a>
        <a href="#">피드백</a>
      </div>
    </div>
  </footer>
</div>

<!-- 모달 -->
<div id="helpModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>EasyAgent 노드 에디터 도움말</h2>
      <button class="close-button" onclick="closeModal()">&times;</button>
    </div>
    <div class="modal-body">
      <h3>기본 사용법</h3>
      <p>1. 왼쪽 사이드바에서 원하는 노드 유형을 클릭하여 캔버스에 추가합니다.</p>
      <p>2. 노드를 클릭하여 선택하면 오른쪽 패널에서 속성을 편집할 수 있습니다.</p>
      <p>3. 노드의 출력 핀에서 다른 노드의 입력 핀으로 드래그하여 연결할 수 있습니다.</p>
      <p>4. 오른쪽 패널 하단에서 생성된 Python 코드를 확인할 수 있습니다.</p>
      
      <h3>노드 유형</h3>
      <ul>
        <li><strong>Start</strong>: 그래프의 시작점입니다.</li>
        <li><strong>End</strong>: 그래프의 종료점입니다.</li>
        <li><strong>LLM</strong>: 언어 모델을 호출합니다.</li>
        <li><strong>Tool</strong>: 외부 도구를 호출합니다.</li>
        <li><strong>Condition</strong>: 조건에 따라 흐름을 분기합니다.</li>
        <li><strong>Output</strong>: 결과를 출력합니다.</li>
        <li><strong>Custom</strong>: 사용자 정의 Python 코드를 실행합니다.</li>
      </ul>
    </div>
  </div>
</div>

<!-- 스크립트 -->
<script src="https://cdn.jsdelivr.net/npm/drawflow/dist/drawflow.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/toastify-js/1.12.0/toastify.min.js"></script>

<script>
// 네임스페이스 생성
const LangGraph = {
  editor: null,
  nodeCount: 0,
  selectedNodeId: null,
  
  // 노드 타입별 기본 데이터
  nodeTemplates: {
    Start: { 
      label: 'Start',
      html: '<div class="title-box">Start</div><div class="description-box">그래프 시작점</div>',
      data: {}
    },
    End: { 
      label: 'End',
      html: '<div class="title-box">End</div><div class="description-box">그래프 종료점</div>',
      data: {}
    },
    LLM: { 
      label: 'LLM',
      html: '<div class="title-box">LLM</div><div class="description-box">언어 모델 호출</div>',
      data: { model: 'gpt-4', prompt: 'Your prompt here' }
    },
    Tool: { 
      label: 'Tool',
      html: '<div class="title-box">Tool</div><div class="description-box">외부 도구 호출</div>',
      data: { tool_name: 'search_tool', description: 'Searches for information' }
    },
    Condition: { 
      label: 'Condition',
      html: '<div class="title-box">Condition</div><div class="description-box">조건 분기</div>',
      data: { 
        condition: 'result.success == True',
        branches: ['true_branch', 'false_branch'] 
      }
    },
    Output: { 
      label: 'Output',
      html: '<div class="title-box">Output</div><div class="description-box">결과 출력</div>',
      data: {}
    },
    Custom: { 
      label: 'Custom',
      html: '<div class="title-box">Custom</div><div class="description-box">사용자 정의 코드</div>',
      data: { code: '# Write your own code here\n\n' }
    }
  },
  
  // 초기화
  init: function() {
    // Drawflow 에디터 초기화
    this.editor = new Drawflow(document.getElementById('drawflow'));
    this.editor.start();
    this.editor.editor_mode = 'edit';
    this.editor.zoom_enable = true;
    this.editor.zoom_value = 1;
    this.editor.zoom_max = 1.6;
    this.editor.zoom_min = 0.5;
    
    // 이벤트 리스너 등록
    this.registerEventListeners();
    
    // 노드 버튼 이벤트 등록
    this.initNodeButtons();
    
    // 키보드 이벤트 등록
    this.initKeyboardShortcuts();
    
    // 사용자에게 알림 표시
    this.showToast('블록 에디터가 준비되었습니다', 'success');

    // 줌 버튼 이벤트 리스너 등록
    document.getElementById('zoom-in').addEventListener('click', () => LangGraph.handleZoom('in'));
    document.getElementById('zoom-out').addEventListener('click', () => LangGraph.handleZoom('out'));
    document.getElementById('zoom-reset').addEventListener('click', () => LangGraph.handleZoom('reset'));

  },
  
  // 이벤트 리스너 등록
  registerEventListeners: function() {
    // 노드 관련 이벤트
    this.editor.on('nodeSelected', this.handleNodeSelected.bind(this));
    this.editor.on('nodeUnselected', this.handleNodeUnselected.bind(this));
    this.editor.on('nodeCreated', this.handleNodeCreated.bind(this));
    this.editor.on('nodeRemoved', this.handleNodeRemoved.bind(this));
    
    // 연결 관련 이벤트
    this.editor.on('connectionCreated', this.handleConnectionCreated.bind(this));
    this.editor.on('connectionRemoved', this.handleConnectionRemoved.bind(this));
    
    // 전체 그래프 변경 이벤트
    this.editor.on('zoom', this.handleZoom.bind(this));
  },
  
  // 노드 버튼 초기화
  initNodeButtons: function() {
    const buttons = document.querySelectorAll('#nodeButtons button');
    buttons.forEach(button => {
      button.addEventListener('click', () => {
        this.addNode(button.dataset.type);
      });
      
      // 툴팁 이벤트
      button.addEventListener('mouseover', (e) => {
        this.showTooltip(e.target, e.target.title);
      });
      
      button.addEventListener('mouseout', () => {
        this.hideTooltip();
      });
    });
    
    // Clear 버튼 이벤트
    document.getElementById('clearButton').addEventListener('click', this.confirmClearAll.bind(this));
    // Import 버튼 이벤트
    document.getElementById('importButton').addEventListener('click', () => {
      document.getElementById('importInput').click();
    });
    document.getElementById('helpButton').addEventListener('click', () => {
      LangGraph.openHelpModal();
    });
    document.getElementById('importInput').addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        const file = e.target.files[0];
        const reader = new FileReader();
        
        reader.onload = (event) => {
          try {
            const jsonData = JSON.parse(event.target.result);
            this.editor.import(jsonData);
            this.updateCode();
            this.showToast('JSON 파일을 성공적으로 가져왔습니다', 'success');
          } catch (error) {
            console.error('JSON 가져오기 오류:', error);
            this.showToast('JSON 파일 가져오기에 실패했습니다', 'error');
          }
        };
        
        reader.readAsText(file);
      }
    });
  },
  
  // 키보드 단축키 초기화
  initKeyboardShortcuts: function() {
    document.addEventListener('keydown', (e) => {
      // Delete 키로 선택된 노드 삭제
      if (e.key === 'Delete' && this.selectedNodeId !== null) {
        this.editor.removeNodeId(this.selectedNodeId);
        this.selectedNodeId = null;
        this.updateFormFields();
        this.updateCode();
        this.showToast('노드가 삭제되었습니다', 'info');
      }
      
      // Ctrl+S로 JSON 저장
      if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        this.exportJson();
      }
      
      // Ctrl+C로 코드 복사
      if (e.ctrlKey && e.key === 'c' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
        e.preventDefault();
        this.copyCode();
      }
      
      // F1 또는 ?로 도움말 표시
      if (e.key === 'F1' || (e.shiftKey && e.key === '?')) {
        e.preventDefault();
        this.openHelpModal();
      }
    });
  },
  
  // 노드 추가
  addNode: function(type) {
    try {
      const editor = document.getElementById('drawflow');
      const posX = 100 + (this.nodeCount % 3) * 250;
      const posY = 100 + Math.floor(this.nodeCount / 3) * 150;
      
      const template = this.nodeTemplates[type];
      if (!template) {
        throw new Error(`알 수 없는 노드 유형: ${type}`);
      }

      let numInputs = 1;
      let numOutputs = 1;

      // Condition 노드일 경우, 브랜치 수만큼 출력 커넥터 수를 설정
      if (type === 'Condition') {
        numOutputs = template.data.branches ? template.data.branches.length : 2; // 기본값 2 (true/false)
        // Condition 노드는 일반적으로 하나의 입력을 받음
      }
      
      const nodeId = this.editor.addNode(
        type,
        numInputs, 
        numOutputs, // 수정된 출력 커넥터 수
        posX,
        posY,
        type,
        { ...template.data, label: template.label }, // 데이터 복사 시 깊은 복사 고려
        template.html
      );
      
      setTimeout(() => {
        const nodeElement = document.querySelector(`.drawflow-node[data-id="${nodeId}"]`);
        if (nodeElement) {
          nodeElement.classList.add(type);
        }
      }, 10); // DOM 업데이트 후 클래스 추가
      
      this.nodeCount++;
      this.updateCode(); // 코드 즉시 업데이트
      this.showToast(`${type} 노드가 추가되었습니다`, 'success');
      
      return nodeId;
    } catch (error) {
      console.error('노드 추가 오류:', error);
      this.showToast('노드를 추가하는 중 오류가 발생했습니다', 'error');
      return null;
    }
  },
  
  // 노드 선택 핸들러
  handleNodeSelected: function(nodeId) {
    this.selectedNodeId = nodeId;
    this.updateFormFields();
    
    // 선택된 노드로 스크롤
    const nodeElement = document.querySelector(`.drawflow-node[data-id="${nodeId}"]`);
    if (nodeElement) {
      nodeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  },
  
  // 노드 선택 해제 핸들러
  handleNodeUnselected: function() {
    this.selectedNodeId = null;
    this.updateFormFields();
  },
  
  // 노드 생성 핸들러
  handleNodeCreated: function() {
    this.updateCode();
  },
  
  // 노드 삭제 핸들러
  handleNodeRemoved: function() {
    this.updateCode();
    if (this.selectedNodeId) {
      this.selectedNodeId = null;
      this.updateFormFields();
    }
  },
  
  // 연결 생성 핸들러
  handleConnectionCreated: function(connection) {
    // 연결 스타일 업데이트
    this.updateConnectionStyle(connection);
    this.updateCode();
    this.showToast('노드가 연결되었습니다', 'info');
    // 연결 유효성 검사 추가
    const sourceNode = this.editor.getNodeFromId(connection.output_id);
    const targetNode = this.editor.getNodeFromId(connection.input_id);
    
    // End 노드는 출력 연결을 가질 수 없음
    if (sourceNode?.name === 'End') {
      this.editor.removeSingleConnection(connection.output_id, connection.input_id, connection.output_class, connection.input_class);
      this.showToast('End 노드는 출력 연결을 가질 수 없습니다', 'error');
      return;
    }
    
    // Start 노드는 입력 연결을 가질 수 없음
    if (targetNode?.name === 'Start') {
      this.editor.removeSingleConnection(connection.output_id, connection.input_id, connection.output_class, connection.input_class);
      this.showToast('Start 노드는 입력 연결을 가질 수 없습니다', 'error');
      return;
    }
    
    // 연결 스타일 업데이트
    this.updateConnectionStyle(connection);
    this.updateCode();
    this.showToast('노드가 연결되었습니다', 'info');
  },
  
  // 연결 삭제 핸들러
  handleConnectionRemoved: function() {
    this.updateCode();
  },
  
  handleZoom: function(zoomType) {
    const editorElement = document.getElementById('drawflow');
    const currentZoom = this.editor.zoom_value;

    if (zoomType === 'in' && currentZoom < this.editor.zoom_max) {
      this.editor.zoom_in();
    } else if (zoomType === 'out' && currentZoom > this.editor.zoom_min) {
      this.editor.zoom_out();
    } else if (zoomType === 'reset') {
      this.editor.zoom_reset();
    }

    // 줌 상태 업데이트
    document.getElementById('zoom-percentage').textContent = `${Math.round(this.editor.zoom_value * 100)}%`;


  },
  


  // 연결 스타일 업데이트
  updateConnectionStyle: function(connection) {
    try {
      // output_class는 'output_1', 'output_2' 등의 값을 가집니다.
      const { input_id, output_id, output_class, input_class } = connection; 
      
      setTimeout(() => {
        const sourceNode = this.editor.getNodeFromId(output_id);
        
        // Drawflow 연결 요소를 정확히 선택합니다.
        // 클래스 이름은 Drawflow 버전에 따라 다를 수 있으므로 확인이 필요할 수 있습니다.
        const connElement = document.querySelector(
            `.connection.node_in_${input_id}.node_out_${output_id}.${output_class}.input_${input_class}`
        );

        if (connElement && sourceNode?.name === 'Condition') {
          connElement.classList.add('condition-connection');
          
          const sourceNodeData = sourceNode.data;
          // sourceNodeData.branches가 정의되지 않았거나 배열이 아닌 경우를 대비하여 기본값 설정
          const branches = Array.isArray(sourceNodeData?.branches) ? sourceNodeData.branches : [];
          
          // output_class (예: "output_1") 에서 브랜치 인덱스 (0-based) 추출
          let branchIndex = -1;
          if (output_class && output_class.startsWith('output_')) {
              branchIndex = parseInt(output_class.split('_')[1], 10) - 1;
          }
            
          if (branchIndex >= 0 && branchIndex < branches.length) {
            // getBranchColor 함수를 사용하여 브랜치별 색상 적용
            connElement.style.setProperty('--branch-color', this.getBranchColor(branchIndex));
          } else {
            // 매칭되는 브랜치가 없거나 인덱스가 잘못된 경우 기본 색상 적용
            connElement.style.setProperty('--branch-color', this.getBranchColor(0)); // 또는 다른 기본값
          }
        }
      }, 100); // DOM 요소가 완전히 그려진 후 스타일을 적용하기 위한 지연
    } catch (error) {
      console.error('연결 스타일 업데이트 오류:', error);
      // 사용자에게 오류를 알리는 토스트 메시지를 추가할 수 있습니다.
      // this.showToast('연결 스타일 업데이트 중 오류 발생', 'error');
    }
  },

// 브랜치별 색상 반환
getBranchColor: function(index) {
  const colors = [
    '#4CAF50', // 녹색 (true)  
    '#F44336', // 빨강 (false)
    '#2196F3', // 파랑
    '#FF9800', // 주황
    '#9C27B0', // 보라
    '#00BCD4'  // 청록
  ];
  return colors[index % colors.length];
},
  // 폼 필드 업데이트
  updateFormFields: function() {
    const formFields = document.getElementById('formFields');
    
    if (!this.selectedNodeId) {
      formFields.innerHTML = '<p>편집할 노드를 선택하세요</p>';
      return;
    }
    
    try {
      const node = this.editor.getNodeFromId(this.selectedNodeId);
      if (!node) {
        throw new Error('선택된 노드를 찾을 수 없습니다');
      }
      
      const data = node.data || {};
      let fieldsHtml = `
        <label>
          블록 이름
          <input id="nodeLabel" value="${data.label || node.name || ''}" placeholder="노드 이름">
        </label>
      `;
      
      // 노드 타입별 필드 추가
      switch (node.name) {
        case 'LLM':
          fieldsHtml += `
            <label>
              모델
              <input id="nodeModel" value="${data.model || ''}" placeholder="예: gpt-4">
            </label>
            <label>
              프롬프트
              <textarea id="nodePrompt" placeholder="언어 모델에 전달할 프롬프트">${data.prompt || ''}</textarea>
            </label>
          `;
          break;
        case 'Tool':
          fieldsHtml += `
            <label>
              도구 이름
              <input id="nodeToolName" value="${data.tool_name || ''}" placeholder="예: search_tool">
            </label>
            <label>
              설명
              <textarea id="nodeDescription" placeholder="도구에 대한 설명">${data.description || ''}</textarea>
            </label>
          `;
          break;
        case 'Condition':
          fieldsHtml += `
            <label>
              조건식
              <input id="nodeCondition" value="${data.condition || ''}" placeholder="예: result.success == True">
            </label>
            <div id="branchContainer">
              <label>브랜치</label>
              ${(data.branches || ['true_branch', 'false_branch']).map((branch, index) => `
                <div class="branch-item" style="display: flex; margin-bottom: 8px;">
                  <input id="branch_${index}" value="${branch}" placeholder="브랜치 이름" style="flex: 1; margin-right: 8px;">
                  <button type="button" onclick="LangGraph.removeBranch(${index})" style="background: #f44336; color: white;">-</button>
                </div>
              `).join('')}
              <button type="button" onclick="LangGraph.addBranch()" style="width: 100%; margin-top: 8px; background: #4CAF50; color: white;">+ 브랜치 추가</button>
            </div>
          `;
          break;
        case 'Custom':
          fieldsHtml += `
            <label>
              사용자 정의 코드
              <textarea id="nodeCode" placeholder="Python 코드 작성" style="min-height: 120px;">${data.code || ''}</textarea>
            </label>
          `;
          break;
      }
      
      fieldsHtml += `<button onclick="LangGraph.saveNodeForm()">변경사항 저장</button>`;
      formFields.innerHTML = fieldsHtml;
    } catch (error) {
      console.error('폼 필드 업데이트 오류:', error);
      formFields.innerHTML = '<p>노드 정보를 불러올 수 없습니다</p>';
    }
  },
  
  // 노드 폼 저장
  saveNodeForm: function() {
    if (!this.selectedNodeId) {
      this.showToast('선택된 노드가 없습니다', 'error');
      return;
    }
    
    try {
      // 기본 필드
      const newData = {};
      const labelInput = document.getElementById('nodeLabel');
      if (labelInput) newData.label = labelInput.value || 'Unnamed Node'; // 기본값 제공
      
      // 노드 유형별 필드
      const node = this.editor.getNodeFromId(this.selectedNodeId);
      switch (node.name) {
        case 'LLM':
          const modelInput = document.getElementById('nodeModel');
          const promptInput = document.getElementById('nodePrompt');
          
          // 필수 필드 검증
          if (!modelInput?.value) {
            this.showToast('모델 이름은 필수입니다', 'error');
            return;
          }
          
          newData.model = modelInput.value;
          newData.prompt = promptInput?.value || '';
          break;
          
        case 'Tool':
          const toolNameInput = document.getElementById('nodeToolName');
          
          // 필수 필드 검증
          if (!toolNameInput?.value) {
            this.showToast('도구 이름은 필수입니다', 'error');
            return;
          }
          
          newData.tool_name = toolNameInput.value;
          newData.description = document.getElementById('nodeDescription')?.value || '';
          break;
          
        case 'Condition':
          const conditionInput = document.getElementById('nodeCondition');
          if (conditionInput) newData.condition = conditionInput.value;
          
          // 브랜치 데이터 수집
          const branches = [];
          let index = 0;
          let branchInput = document.getElementById(`branch_${index}`);
          while (branchInput) {
            if (branchInput.value.trim()) {
              branches.push(branchInput.value.trim());
            }
            index++;
            branchInput = document.getElementById(`branch_${index}`);
          }
          
          // 최소 2개의 브랜치 보장
          if (branches.length < 2) {
            branches.push('true_branch', 'false_branch');
          }
          
          newData.branches = branches;
          break;
          
        case 'Custom':
          const codeInput = document.getElementById('nodeCode');
          if (codeInput) newData.code = codeInput.value;
          break;
      }
      
      // 노드 데이터 업데이트
      this.editor.updateNodeDataFromId(this.selectedNodeId, newData);
      
      // 노드 UI 업데이트
      this.updateNodeUI(this.selectedNodeId, newData);
      
      // 코드 재생성
      this.updateCode();
      
      this.showToast('노드가 업데이트되었습니다', 'success');
    } catch (error) {
      console.error('노드 저장 오류:', error);
      this.showToast('노드 업데이트 중 오류가 발생했습니다', 'error');
    }
  },
  
   // 노드 UI 업데이트
  updateNodeUI: function(nodeId, data) {
    try {
      const node = this.editor.getNodeFromId(nodeId);
      if (!node) return;
      
      // 노드 데이터 및 HTML 업데이트
      if (data.label) {
        // HTML 내용 생성
        const html = `<div class="title-box">${data.label}</div><div class="description-box">${this.getNodeDescription(node.name, data)}</div>`;
        
        // 노드 HTML 업데이트 (내부 데이터)
        node.html = html;
        
        // DOM에 직접 반영 - 정확한 셀렉터로 요소 찾기
        const nodeElement = document.querySelector(`#node-${nodeId} .drawflow_content_node`);
        if (nodeElement) {
          nodeElement.innerHTML = html;
        } else {
          // 대체 셀렉터 시도
          const altNodeElement = document.querySelector(`.drawflow-node[data-id="${nodeId}"] .drawflow_content_node`);
          if (altNodeElement) {
            altNodeElement.innerHTML = html;
          } else {
            console.warn(`노드 요소를 찾을 수 없음: ${nodeId}`);
          }
        }
      }
    } catch (error) {
      console.error('노드 UI 업데이트 오류:', error);
    }
  },
  
  // 노드 설명 반환
  getNodeDescription: function(nodeType, data) {
    switch (nodeType) {
      case 'Start': return '그래프 시작점';
      case 'End': return '그래프 종료점';
      case 'LLM': return data.model ? `Model: ${data.model}` : '언어 모델 호출';
      case 'Tool': return data.tool_name ? `Tool: ${data.tool_name}` : '외부 도구 호출';
      case 'Condition': return data.condition ? `If: ${data.condition}` : '조건 분기';
      case 'Output': return '결과 출력';
      case 'Custom': return '사용자 정의 코드';
      default: return '';
    }
  },
  

  // 브랜치 추가
  addBranch: function() {
    const branchContainer = document.getElementById('branchContainer');
    if (!branchContainer) return;
    
    const branchItems = branchContainer.querySelectorAll('.branch-item');
    const newIndex = branchItems.length;
    
    const newBranchDiv = document.createElement('div');
    newBranchDiv.className = 'branch-item';
    newBranchDiv.style = 'display: flex; margin-bottom: 8px;';
    newBranchDiv.innerHTML = `
      <input id="branch_${newIndex}" placeholder="브랜치 이름" style="flex: 1; margin-right: 8px;">
      <button type="button" onclick="LangGraph.removeBranch(${newIndex})" style="background: #f44336; color: white;">-</button>
    `;
    
    // 버튼 앞에 삽입
    const addButton = branchContainer.querySelector('button[onclick="LangGraph.addBranch()"]');
    branchContainer.insertBefore(newBranchDiv, addButton);
  },

  // 브랜치 제거
  removeBranch: function(index) {
    const branchItem = document.getElementById(`branch_${index}`).parentNode;
    if (branchItem) {
      branchItem.remove();
      
      // 인덱스 재정렬
      this.reindexBranches();
    }
  },

  // 브랜치 인덱스 재정렬
  reindexBranches: function() {
    const branchContainer = document.getElementById('branchContainer');
    if (!branchContainer) return;
    
    const branchItems = branchContainer.querySelectorAll('.branch-item');
    branchItems.forEach((item, i) => {
      const input = item.querySelector('input');
      const button = item.querySelector('button');
      
      input.id = `branch_${i}`;
      button.setAttribute('onclick', `LangGraph.removeBranch(${i})`);
    });
  },


  // 코드 생성
  updateCode: function() {
    try {
      const data = this.editor.export();
      if (!data.drawflow || !data.drawflow.Home || !data.drawflow.Home.data) {
        document.getElementById('codeOutput').textContent = '# 블록을 추가해보세요';
        Prism.highlightElement(document.getElementById('codeOutput'));
        return;
      }
      
      const graph = data.drawflow.Home.data;
      
      // 노드 간 연결 정보 수집
      const edges = Object.fromEntries(
        Object.entries(graph).map(([id, node]) => [
          id, 
          node.outputs?.output_1?.connections.map(c => c.node.toString()) || []
        ])
      );
      
      const visited = new Set();
      const codeLines = [
        '# LangGraph 자동 생성 코드',
        'from typing import Dict, List, Any',
        'from langchain_core.language_models import ChatOpenAI',
        'from langchain.tools import tool',
        'from langgraph.graph import StateGraph, END',
        '',
        '# 상태 정의',
        'class State(dict):',
        '    """그래프 상태 객체"""',
        '    def __init__(self, **kwargs):',
        '        super().__init__(**kwargs)',
        '        for key, value in kwargs.items():',
        '            setattr(self, key, value)',
        '',
        '# 그래프 생성',
        'def create_graph():',
        '    """LangGraph 워크플로우 생성"""',
        '    graph = StateGraph(State)',
        ''
      ];
      
      // 노드 방문 함수
      const processNode = (nodeId) => {
        if (visited.has(nodeId)) return;
        visited.add(nodeId);
        
        const node = graph[nodeId];
        if (!node) return;
        
        const nodeName = (node.data.label || node.name).toLowerCase().replace(/\s+/g, '_');
        
        switch (node.name) {
          case 'Start':
            codeLines.push('    # 시작 노드');
            codeLines.push(`    # ${node.data.label || 'Start'}`);
            break;
            
          case 'End':
            codeLines.push('    # 종료 노드');
            codeLines.push(`    # ${node.data.label || 'End'}`);
            codeLines.push('    graph.add_node("end", END)');
            break;
            
          case 'LLM':
            codeLines.push(`    # LLM 노드: ${node.data.label || 'LLM'}`);
            codeLines.push(`    def ${nodeName}_node(state):`);
            codeLines.push(`        """${node.data.label || 'LLM 호출'}"""`);
            codeLines.push(`        llm = ChatOpenAI(model='${node.data.model || 'gpt-4'}')`);
            codeLines.push(`        response = llm.invoke("${node.data.prompt?.replace(/"/g, '\\"') || 'Your prompt here'}")`);
            codeLines.push('        return {"response": response}');
            codeLines.push('');
            codeLines.push(`    graph.add_node("${nodeName}", ${nodeName}_node)`);
            break;
            
          case 'Tool':
            codeLines.push(`    # Tool 노드: ${node.data.label || 'Tool'}`);
            codeLines.push('    @tool');
            codeLines.push(`    def ${node.data.tool_name || 'tool_function'}(query: str) -> str:`);
            codeLines.push(`        """${node.data.description || 'Tool description'}"""`);
            codeLines.push('        # 도구 구현');
            codeLines.push('        return f"Result for {query}"');
            codeLines.push('');
            codeLines.push(`    def ${nodeName}_node(state):`);
            codeLines.push(`        result = ${node.data.tool_name || 'tool_function'}(state.get("query", ""))`);
            codeLines.push('        return {"tool_result": result}');
            codeLines.push('');
            codeLines.push(`    graph.add_node("${nodeName}", ${nodeName}_node)`);
            break;
            
          case 'Condition':
            const conditionLogic = node.data.condition || 'True'; // UI에서 입력된 조건
            const branches = Array.isArray(node.data.branches) && node.data.branches.length > 0 
                             ? node.data.branches 
                             : ['true_branch', 'false_branch']; // UI에서 정의된 브랜치 또는 기본값

            codeLines.push(`    # Condition 노드: ${node.data.label || 'Condition'}`);

            // 1. Condition 노드 자체의 메인 로직 함수 정의
            codeLines.push(`    def ${nodeName}_main_logic(state):`);
            codeLines.push(`        """'${node.data.label || 'Condition'}' 노드의 메인 로직입니다."""`);
            codeLines.push(`        # 라우팅 전에 실행되어야 하는 로직을 여기에 추가할 수 있습니다.`);
            codeLines.push(`        # 예를 들어, 상태(state)를 변경하거나 라우팅 결정에 필요한 값을 준비합니다.`);
            codeLines.push(`        print(f"--- 노드 실행: ${nodeName} (${node.data.label || 'Condition'}) ---")`);
            codeLines.push(`        return state`); // 기본적으로 상태를 그대로 반환
            codeLines.push('');
            codeLines.push(`    graph.add_node("${nodeName}", ${nodeName}_main_logic)`);
            codeLines.push('');

            // 2. 라우터 함수 정의
            codeLines.push(`    def ${nodeName}_router(state):`);
            codeLines.push(`        """'${node.data.label || 'Condition'}' 노드의 라우터 함수입니다.""`);
            codeLines.push(`        # UI에서 설정된 조건: ${conditionLogic}`);
            codeLines.push(`        # 이 라우터는 다음 브랜치 이름 중 하나를 반환해야 합니다:`);
            codeLines.push(`        # ${branches.map(b => `"${b}"`).join(', ')}`);
            
            if (branches.length === 0) {
                codeLines.push('        # 경고: 정의된 브랜치가 없습니다. 기본적으로 END로 라우팅합니다.');
                codeLines.push('        return END');
            } else if (branches.length === 1) {
                codeLines.push(`        # 단일 브랜치: "${branches[0]}"가 정의되어 있습니다.`);
                codeLines.push(`        # 조건 (${conditionLogic}) 평가 결과와 관계없이 항상 "${branches[0]}" 브랜치로 라우팅합니다.`);
                codeLines.push(`        print(f"--- 라우터 (${nodeName}): 단일 브랜치 '${branches[0]}'로 라우팅 ---")`);
                codeLines.push(`        return "${branches[0]}"`);
            } else { // 2개 이상의 브랜치가 있는 경우
                codeLines.push(`        evaluated_condition = ${conditionLogic}`);
                codeLines.push(`        print(f"--- 라우터 (${nodeName}): 조건 \\"${conditionLogic}\\" 평가 결과: {evaluated_condition} ---")`);
                codeLines.push(`        if evaluated_condition:`);
                codeLines.push(`            print(f"--- 라우터 (${nodeName}): 조건 TRUE, 브랜치 '${branches[0]}'로 라우팅 ---")`);
                codeLines.push(`            return "${branches[0]}"`); // 조건이 참일 때 첫 번째 브랜치
                codeLines.push(`        else:`);
                codeLines.push(`            print(f"--- 라우터 (${nodeName}): 조건 FALSE, 브랜치 '${branches[1]}'로 라우팅 ---")`);
                codeLines.push(`            return "${branches[1]}"`); // 조건이 거짓일 때 두 번째 브랜치
                
                if (branches.length > 2) {
                    codeLines.push('');
                    codeLines.push(`        # 중요: 현재 자동 생성된 라우팅 로직은 위에서 정의된`);
                    codeLines.push(`        # 두 개의 브랜치('${branches[0]}' 또는 '${branches[1]}')만 처리합니다.`);
                    codeLines.push(`        # 나머지 브랜치(${branches.slice(2).map(b => `"${b}"`).join(', ')})로 라우팅하려면,`);
                    codeLines.push(`        # 아래 주석 처리된 예시처럼 이 라우터 함수의 로직을 직접 수정해야 합니다.`);
                    codeLines.push(`        # 예를 들어, state의 다른 값을 확인하여 특정 추가 브랜치로 보낼 수 있습니다.`);
                    codeLines.push(`        #`);
                    codeLines.push(`        # 예시 (수정 필요):`);
                    codeLines.push(`        # next_step = state.get("custom_routing_key", None)`);
                    codeLines.push(`        # if evaluated_condition:`);
                    codeLines.push(`        #     if next_step == "option_for_true_branch_variant":`);
                    codeLines.push(`        #         return "${branches[0]}" # 또는 다른 브랜치`);
                    codeLines.push(`        #     return "${branches[0]}"`);
                    codeLines.push(`        # else:`);
                    codeLines.push(`        #     if next_step == "${branches[2]}": # branches[2]가 실제 브랜치 이름이라고 가정`);
                    codeLines.push(`        #         return "${branches[2]}"`);
                    codeLines.push(`        #     elif next_step == "${branches[3]}": # branches[3]이 실제 브랜치 이름이라고 가정`);
                    codeLines.push(`        #         return "${branches[3]}"`);
                    codeLines.push(`        #     return "${branches[1]}"`);
                    codeLines.push(`        #`);
                    codeLines.push(`        # 또는, 모든 조건을 명시적으로 처리:`);
                    codeLines.push(`        # if condition_for_branch_0: return "${branches[0]}"`);
                    codeLines.push(`        # elif condition_for_branch_1: return "${branches[1]}"`);
                    branches.slice(2).forEach(branch => {
                    codeLines.push(`        # elif condition_for_${branch.replace(/[^a-zA-Z0-9_]/g, '')}: return "${branch}"`);
                    });
                    codeLines.push(`        # else: return "default_branch_or_END"`);
                }
            }
            codeLines.push('');

            // 3. 조건부 엣지(연결) 추가
            codeLines.push(`    graph.add_conditional_edges(`);
            codeLines.push(`        "${nodeName}",`); // 소스 노드 이름
            codeLines.push(`        ${nodeName}_router,`); // 라우터 함수
            codeLines.push('        {');
            
            const branchToTargetMap = {};
            if (node.outputs) {
                for (const outputKey in node.outputs) {
                    if (node.outputs.hasOwnProperty(outputKey) && outputKey.startsWith('output_')) {
                        const outputIndex = parseInt(outputKey.split('_')[1], 10) - 1; // 0-indexed
                        
                        if (outputIndex >= 0 && outputIndex < branches.length) {
                            const branchName = branches[outputIndex];
                            const connectionsToThisBranch = node.outputs[outputKey].connections;
                            
                            if (connectionsToThisBranch && connectionsToThisBranch.length > 0) {
                                const targetNodeId = connectionsToThisBranch[0].node;
                                const targetNodeData = graph[targetNodeId];
                                
                                if (targetNodeData) {
                                    const targetName = (targetNodeData.data.label || targetNodeData.name).toLowerCase().replace(/\s+/g, '_');
                                    branchToTargetMap[branchName] = targetName;
                                } else {
                                     branchToTargetMap[branchName] = "END";
                                     console.warn(`Condition node ${nodeName}, branch ${branchName} is connected to a non-existing node ID ${targetNodeId}. Defaulting to END.`);
                                }
                            } else {
                                branchToTargetMap[branchName] = "END"; 
                                codeLines.push(`            # 경고: '${branchName}' 브랜치에 연결된 노드가 없습니다. '${branchName}': "END"로 자동 매핑됩니다.`);
                            }
                        }
                    }
                }
            }
            // UI에서 정의했지만, 시각적으로 연결되지 않은 브랜치도 END로 매핑 (또는 다른 기본값)
            branches.forEach(branchName => {
                if (!branchToTargetMap.hasOwnProperty(branchName)) {
                    branchToTargetMap[branchName] = "END";
                    codeLines.push(`            # 정보: '${branchName}' 브랜치는 UI에 정의되었으나, 연결되지 않아 '${branchName}': "END"로 자동 매핑됩니다.`);
                }
            });

            const branchMappingLines = Object.entries(branchToTargetMap)
                .map(([branch, target]) => `            "${branch}": "${target}"`);

            if (branchMappingLines.length > 0) {
                codeLines.push(branchMappingLines.join(',\n'));
            } else {
                codeLines.push('            # 매핑된 브랜치 연결이 없습니다. 모든 경로는 END로 이어질 수 있습니다.');
            }
            codeLines.push('        }');
            codeLines.push('    )');
            break;
            
          case 'Output':
            codeLines.push(`    # Output 노드: ${node.data.label || 'Output'}`);
            codeLines.push(`    def ${nodeName}_node(state):`);
            codeLines.push('        """결과 출력"""');
            codeLines.push('        print(f"Output: {state.get(\'response\', \'No response\')}")')
            codeLines.push('        return state');
            codeLines.push('');
            codeLines.push(`    graph.add_node("${nodeName}", ${nodeName}_node)`);
            break;
            
          case 'Custom':
            codeLines.push(`    # Custom 노드: ${node.data.label || 'Custom'}`);
            codeLines.push(`    def ${nodeName}_node(state):`);
            const customCode = node.data.code?.trim() || '# Custom code';
            // 들여쓰기 처리
            customCode.split('\n').forEach(line => {
              codeLines.push(`        ${line}`);
            });
            codeLines.push('        return state');
            codeLines.push('');
            codeLines.push(`    graph.add_node("${nodeName}", ${nodeName}_node)`);
            break;
        }
        
        // 다음 노드 처리
        edges[nodeId].forEach(nextNodeId => {
          processNode(nextNodeId);
        });
      };
      
      // 시작 노드 찾기 및 처리
      let startNode = null;
      Object.entries(graph).forEach(([id, node]) => {
        if (node.name === 'Start') {
          startNode = id;
        }
      });
      
      // 시작 노드부터 DFS 수행
      if (startNode) {
        processNode(startNode);
      } else {
        // 시작 노드가 없으면 모든 노드 처리
        Object.keys(graph).forEach(processNode);
      }
      
      // 엣지 연결 코드 생성
      codeLines.push('    # 노드 연결');
      Object.entries(edges).forEach(([nodeId, targets]) => {
        const sourceNode = graph[nodeId];
        if (!sourceNode) return;
        
        const sourceName = (sourceNode.data.label || sourceNode.name).toLowerCase().replace(/\s+/g, '_');
        
        targets.forEach(targetId => {
          const targetNode = graph[targetId];
          if (!targetNode) return;
          
          const targetName = (targetNode.data.label || targetNode.name).toLowerCase().replace(/\s+/g, '_');
          
          // Condition 노드는 이미 처리했으므로 건너뜀
          if (sourceNode.name !== 'Condition') {
            codeLines.push(`    graph.add_edge("${sourceName}", "${targetName}")`);
          }
        });
      });
      
      // 그래프 실행 코드
      codeLines.push('');
      codeLines.push('    return graph');
      codeLines.push('');
      codeLines.push('# 그래프 실행');
      codeLines.push('if __name__ == "__main__":');
      codeLines.push('    graph = create_graph()');
      codeLines.push('    # 초기 상태 설정');
      codeLines.push('    initial_state = State(query="한국의 수도는 어디인가요?")');
      codeLines.push('    # 그래프 실행');
      codeLines.push('    graph.invoke(initial_state)');
      
      // 코드 표시
      const finalCode = codeLines.join('\n');
      document.getElementById('codeOutput').textContent = finalCode;
      Prism.highlightElement(document.getElementById('codeOutput'));
    } catch (error) {
      console.error('코드 생성 오류:', error);
      document.getElementById('codeOutput').textContent = `# 오류 발생: ${error.message}`;
      Prism.highlightElement(document.getElementById('codeOutput'));
      this.showToast('코드 생성 중 오류가 발생했습니다', 'error');
    }
  },
  
  // JSON 내보내기
  exportJson: function() {
    try {
      const dataStr = JSON.stringify(this.editor.export(), null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'langgraph_flow.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      this.showToast('JSON 파일이 저장되었습니다', 'success');
    } catch (error) {
      console.error('JSON 내보내기 오류:', error);
      this.showToast('JSON 내보내기 중 오류가 발생했습니다', 'error');
    }
  },
  
  // 코드 복사
  copyCode: function() {
    try {
      const codeOutput = document.getElementById('codeOutput');
      const tempTextarea = document.createElement('textarea');
      tempTextarea.value = codeOutput.textContent;
      document.body.appendChild(tempTextarea);
      tempTextarea.select();
      document.execCommand('copy');
      document.body.removeChild(tempTextarea);
      
      this.showToast('코드가 클립보드에 복사되었습니다', 'success');
    } catch (error) {
      console.error('코드 복사 오류:', error);
      this.showToast('코드 복사 중 오류가 발생했습니다', 'error');
    }
  },
  
  // 모든 노드 삭제 확인
  confirmClearAll: function() {
    if (confirm('모든 노드를 삭제하시겠습니까?')) {
      this.editor.clear();
      this.nodeCount = 0;
      this.selectedNodeId = null;
      this.updateFormFields();
      this.updateCode();
      this.showToast('모든 노드가 삭제되었습니다', 'info');
    }
  },
  
  // 툴팁 표시
  showTooltip: function(element, text) {
    const tooltip = document.getElementById('tooltip');
    const rect = element.getBoundingClientRect();
    
    tooltip.textContent = text;
    tooltip.style.left = `${rect.left + rect.width / 2 - tooltip.offsetWidth / 2}px`;
    tooltip.style.top = `${rect.bottom + 5}px`;
    tooltip.style.opacity = '1';
  },
  
  // 툴팁 숨기기
  hideTooltip: function() {
    const tooltip = document.getElementById('tooltip');
    tooltip.style.opacity = '0';
  },
  
  // 도움말 모달 열기
  openHelpModal: function() {
    const modal = document.getElementById('helpModal');
    modal.style.display = 'flex';
  },
  
  // 모달 닫기
  closeModal: function() {
    const modals = document.querySelectorAll('.modal');
    modals.forEach(modal => {
      modal.style.display = 'none';
    });
  },
  
  //미리보기 실행
  previewExecution: function() {
  const data = this.editor.export();
  if (!data.drawflow?.Home?.data) {
    this.showToast('미리보기할 그래프가 없습니다', 'error');
    return;
  }
  
  const graph = data.drawflow.Home.data;
  
  // 시작 노드 찾기
  let startNodeId = null;
  Object.entries(graph).forEach(([id, node]) => {
    if (node.name === 'Start') {
      startNodeId = id;
    }
  });
  
  if (!startNodeId) {
    this.showToast('시작 노드가 필요합니다', 'error');
    return;
  }
  
  // 실행 흐름 결과를 보여주는 모달 생성
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.display = 'flex';
  
  const modalContent = document.createElement('div');
  modalContent.className = 'modal-content';
  modalContent.style.width = '80%';
  modalContent.style.maxWidth = '800px';
  
  const header = document.createElement('div');
  header.className = 'modal-header';
  header.innerHTML = `
    <h2>실행 흐름 미리보기</h2>
    <button class="close-button" onclick="LangGraph.closeModal()">&times;</button>
  `;
  
  const body = document.createElement('div');
  body.className = 'modal-body';
  body.innerHTML = '<div id="execution-preview" style="max-height: 400px; overflow-y: auto;"></div>';
  
  modalContent.appendChild(header);
  modalContent.appendChild(body);
  modal.appendChild(modalContent);
  document.body.appendChild(modal);
  
  // 실행 흐름 시뮬레이션 및 표시
  this.simulateExecution(startNodeId, graph, document.getElementById('execution-preview'));
},

simulateExecution: function(nodeId, graph, container) {
  const visited = new Set();
  const state = { query: "한국의 수도는 어디인가요?" };
  
  const simulateNode = (id, depth = 0) => {
    if (visited.has(id)) return;
    visited.add(id);
    
    const node = graph[id];
    if (!node) return;
    
    const nodeDiv = document.createElement('div');
    nodeDiv.style.marginLeft = `${depth * 20}px`;
    nodeDiv.style.padding = '10px';
    nodeDiv.style.marginBottom = '10px';
    nodeDiv.style.borderLeft = '2px solid #2196F3';
    nodeDiv.style.backgroundColor = '#f5f5f5';
    nodeDiv.style.borderRadius = '4px';
    
    // 노드 메타데이터 표시
    const nodeLabel = node.data.label || node.name;
    nodeDiv.innerHTML = `<h4 style="margin: 0 0 10px 0;">${nodeLabel} (${node.name})</h4>`;
    
    // 노드 유형별 동작 시뮬레이션
    switch (node.name) {
      case 'Start':
        nodeDiv.innerHTML += `<p>초기 상태: ${JSON.stringify(state)}</p>`;
        break;
        
      case 'End':
        nodeDiv.innerHTML += `<p>실행 종료, 최종 상태: ${JSON.stringify(state)}</p>`;
        break;
        
      case 'LLM':
        const response = '이는 LLM 응답의 시뮬레이션입니다. 실제 응답은 다를 수 있습니다.';
        state.response = response;
        nodeDiv.innerHTML += `<p>프롬프트: ${node.data.prompt || '지정되지 않음'}</p>`;
        nodeDiv.innerHTML += `<p>응답: ${response}</p>`;
        break;
        
      case 'Tool':
        const result = `${node.data.tool_name || 'tool'} 실행 결과`;
        state.tool_result = result;
        nodeDiv.innerHTML += `<p>도구: ${node.data.tool_name || '지정되지 않음'}</p>`;
        nodeDiv.innerHTML += `<p>결과: ${result}</p>`;
        break;
        
        case 'Condition':
        const condition = node.data.condition || 'True';
        const branches = node.data.branches || ['true_branch', 'false_branch'];
        const actualConnections = node.outputs?.output_1?.connections || [];
        let simulatedBranch = 'N/A';
        if (actualConnections.length > 0) {
            // 실제 연결된 노드가 있다면, 그 중 첫번째 브랜치를 시뮬레이션 대상으로 가정
            // Drawflow의 내부 ID와 우리가 정의한 branch 이름 간의 매핑이 필요할 수 있음
            // 여기서는 단순히 첫 번째 연결된 브랜치의 이름을 사용한다고 가정
            const firstConnectedNodeId = actualConnections[0].node;
            const firstConnectedNode = graph[firstConnectedNodeId];
            if (firstConnectedNode) {
                // Condition 노드의 branches 배열에서 실제 연결과 매칭되는 이름을 찾아야 할 수 있습니다.
                // 지금은 단순화를 위해 첫 번째 정의된 브랜치 이름을 사용합니다.
                simulatedBranch = branches[0];
            }
        }

        nodeDiv.innerHTML += `<p>조건식: ${condition}</p>`;
        if (actualConnections.length > 0) {
            nodeDiv.innerHTML += `<p>시뮬레이션된 브랜치: ${simulatedBranch} (미리보기는 첫 번째 유효 경로를 따릅니다)</p>`;
        } else {
            nodeDiv.innerHTML += `<p>연결된 브랜치가 없어 시뮬레이션 경로를 결정할 수 없습니다.</p>`;
        }
        break;
        
      case 'Output':
        nodeDiv.innerHTML += `<p>출력: ${state.response || state.tool_result || '결과 없음'}</p>`;
        break;
        
      case 'Custom':
        nodeDiv.innerHTML += `<p>사용자 정의 코드 실행</p>`;
        nodeDiv.innerHTML += `<pre style="background: #f0f0f0; padding: 5px;">${node.data.code || '# 코드 없음'}</pre>`;
        break;
    }
    
    container.appendChild(nodeDiv);
    
    // 다음 노드 처리
    const outputs = node.outputs?.output_1?.connections || [];
    
    if (node.name === 'Condition') {
      if (outputs.length > 0) {
        // Condition 노드의 경우, 미리보기에서는 첫 번째 유효한 연결을 따라 시뮬레이션합니다.
        const nextNodeId = outputs[0].node;
        container.appendChild(document.createComment(` Condition: Simulating path to node ${nextNodeId} `));
        simulateNode(nextNodeId, graph, container, depth + 1); // graph와 container를 전달
      } else {
        const noBranchMsg = document.createElement('p');
        noBranchMsg.textContent = '알림: 이 조건 노드에 연결된 실행 경로가 없습니다.';
        noBranchMsg.style.fontStyle = 'italic';
        noBranchMsg.style.color = '#757575';
        nodeDiv.appendChild(noBranchMsg); // nodeDiv는 현재 노드의 div입니다.
      }
    } else {
      // 일반 노드는 모든 출력 연결 시뮬레이션
      outputs.forEach(conn => {
        simulateNode(conn.node, graph, container, depth + 1); // graph와 container를 전달
      });
    }
  };
  
  simulateNode(nodeId);
},


  // 알림 표시
  showToast: function(message, type = 'info') {
    const bgColors = {
      success: 'linear-gradient(to right, #00b09b, #96c93d)',
      error: 'linear-gradient(to right, #ff5f6d, #ffc371)',
      info: 'linear-gradient(to right, #2193b0, #6dd5ed)',
      warning: 'linear-gradient(to right, #f2994a, #f2c94c)'
    };
    
    Toastify({
      text: message,
      duration: 3000,
      gravity: 'bottom',
      position: 'right',
      backgroundColor: bgColors[type] || bgColors.info,
      stopOnFocus: true
    }).showToast();
  }
};

// 초기화
document.addEventListener('DOMContentLoaded', () => {
  LangGraph.init();
  
  // 모달 외부 클릭시 닫기
  window.addEventListener('click', (e) => {
    const modals = document.querySelectorAll('.modal');
    modals.forEach(modal => {
      if (e.target === modal) {
        modal.style.display = 'none';
      }
    });
  });
});


// 전역 함수 노출
window.exportJson = function() { LangGraph.exportJson(); };
window.copyCode = function() { LangGraph.copyCode(); };
window.closeModal = function() { LangGraph.closeModal(); };
window.previewExecution = function() {LangGraph.previewExecution(); };


</script>
</body>
</html>