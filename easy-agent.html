<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>LangGraph Node Editor - Improved</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- 외부 라이브러리 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/drawflow/dist/drawflow.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastify-js/1.12.0/toastify.min.css">
  
  <style>
    :root {
      --primary-color: #2196F3;
      --primary-dark: #1565C0;
      --secondary-color: #4CAF50;
      --secondary-dark: #388E3C;
      --background-light: #f5f5f5;
      --border-color: #ccc;
      --shadow-color: rgba(0, 0, 0, 0.1);
    }

    html, body { 
      margin: 0; 
      padding: 0; 
      height: 100%; 
      overflow: hidden; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    .container { 
      display: flex; 
      height: 100vh; 
      width: 100vw; 
    }
    
    /* 사이드바 */
    .sidebar {
      width: 240px;
      background: var(--background-light);
      border-right: 1px solid var(--border-color);
      padding: 1rem;
      overflow-y: auto;
      box-shadow: 2px 0 5px var(--shadow-color);
      z-index: 10;
    }
    
    .sidebar h3 {
      margin-top: 0;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .sidebar button {
      width: 100%;
      padding: 1rem;
      margin-bottom: 12px;
      font-size: 1.1rem;
      background: #fff;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .sidebar button:hover {
      background: #e9f5ff;
      border-color: var(--primary-color);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px var(--shadow-color);
    }
    
    .sidebar button:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px var(--shadow-color);
    }
    
    .sidebar button::after {
      content: "+";
      font-size: 1.2rem;
      color: var(--primary-color);
    }

    /* 에디터 영역 */
    .editor-container {
      flex: 2;
      position: relative;
      display: flex;
      background-color: #fafafa;
    }
    
    .editor-background {
      width: 100%;
      height: 100%;
      background-image: radial-gradient(#ddd 1px, transparent 1px);
      background-size: 20px 20px;
    }

    /* 코드 뷰어 */
    .code-viewer {
      width: 30%;
      background: #fff;
      border-left: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      box-shadow: -2px 0 5px var(--shadow-color);
    }
    
    .code-viewer-content, .code-viewer-edit {
      flex: 1;
      padding: 1rem;
      overflow-y: auto;
    }
    
    .code-viewer-edit {
      background: #fff;
      border-top: 1px solid var(--border-color);
    }
    
    .code-viewer-edit h4 { 
      margin-top: 0; 
      color: var(--primary-dark);
    }
    
    .code-viewer-edit label {
      display: block;
      margin-top: 12px;
      font-weight: 500;
    }
    
    .code-viewer-edit input, .code-viewer-edit textarea {
      width: 100%;
      margin-top: 5px;
      padding: 8px;
      box-sizing: border-box;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-family: inherit;
    }
    
    .code-viewer-edit textarea {
      min-height: 80px;
      resize: vertical;
    }
    
    .code-viewer-edit input:focus, .code-viewer-edit textarea:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
    }
    
    .code-viewer-edit button {
      margin-top: 15px;
      padding: 8px 12px;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    .code-viewer-edit button:hover {
      background-color: var(--primary-dark);
    }
    
    .code-viewer-content h3 {
      margin-top: 0;
      color: var(--primary-dark);
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .code-viewer-actions {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    
    .code-viewer-actions button {
      flex: 1;
      padding: 8px 12px;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    .code-viewer-actions button:hover {
      background-color: var(--primary-dark);
    }
    
    .code-viewer-actions button.secondary {
      background-color: #f5f5f5;
      color: #333;
      border: 1px solid var(--border-color);
    }
    
    .code-viewer-actions button.secondary:hover {
      background-color: #e0e0e0;
    }
    
    pre {
      background: #f8f8f8;
      padding: 1rem;
      border-radius: 6px;
      border: 1px solid #e0e0e0;
      white-space: pre-wrap;
      overflow-x: auto;
      margin: 0;
    }

    /* 노드 스타일 */
    .drawflow .drawflow-node {
      background: white;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      box-shadow: 0 2px 10px var(--shadow-color);
      padding: 10px 15px;
      transition: box-shadow 0.3s, transform 0.3s;
    }
    
    .drawflow .drawflow-node:hover {
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      transform: translateY(-2px);
    }
    
    .drawflow .drawflow-node.selected {
      border: 2px solid var(--primary-color);
      box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.2);
    }
    
    .drawflow .drawflow-node .title-box {
      padding-bottom: 5px;
      margin-bottom: 5px;
      border-bottom: 1px solid var(--border-color);
      font-weight: bold;
      color: var(--primary-dark);
    }
    
    .drawflow .drawflow-node .description-box {
      font-size: 0.9rem;
      color: #666;
    }

    /* 특수 노드 스타일 */
    .drawflow .drawflow-node.Start {
      background-color: #e8f5e9;
      border-color: var(--secondary-color);
    }
    
    .drawflow .drawflow-node.End {
      background-color: #ffebee;
      border-color: #f44336;
    }
    
    .drawflow .drawflow-node.LLM {
      background-color: #e3f2fd;
    }
    
    .drawflow .drawflow-node.Tool {
      background-color: #fff3e0;
    }
    
    .drawflow .drawflow-node.Condition {
      background-color: #f3e5f5;
    }

    /* 연결선 스타일 */
    .drawflow .connection .main-path {
      stroke: var(--primary-color);
      stroke-width: 3px;
      fill: none;
      transition: stroke 0.3s ease;
    }
    
    .drawflow .connection:hover .main-path {
      stroke: var(--primary-dark);
      stroke-width: 4px;
    }
    
    .drawflow .connection.condition-connection .main-path {
      stroke: var(--secondary-color);
      stroke-dasharray: 5, 5;
    }
    
    .drawflow .connection.condition-connection:hover .main-path {
      stroke: var(--secondary-dark);
    }
    
    .drawflow .connection.selected .main-path {
      stroke: var(--primary-dark);
      stroke-width: 4px;
    }
    
    /* 툴팁 스타일 */
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 0.8rem;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    /* 모달 스타일 */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    
    .modal-content {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      width: 80%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .modal-header h2 {
      margin: 0;
    }
    
    .close-button {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
    }
    
    /* 로딩 스피너 */
    .spinner {
      border: 4px solid rgba(0, 0, 0, 0.1);
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border-left-color: var(--primary-color);
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .connection.condition-connection .main-path {
      stroke: var(--branch-color, var(--secondary-color));
      stroke-dasharray: 5, 5;
    }

    .connection.condition-connection:hover .main-path {
      stroke: var(--branch-color, var(--secondary-dark));
      stroke-width: 4px;
    }

    .branch-item {
      margin-bottom: 8px;
      animation: fadeIn 0.3s;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

  </style>
</head>

<body>
<div class="container">
  
  <!-- 사이드바 -->
  <div class="sidebar">
    <h3>LangGraph 블록</h3>
    <div id="nodeButtons">
      <button data-type="Start" title="그래프 시작점">Start</button>
      <button data-type="End" title="그래프 종료점">End</button>
      <button data-type="LLM" title="언어 모델 호출">LLM</button>
      <button data-type="Tool" title="외부 도구 호출">Tool</button>
      <button data-type="Condition" title="조건 분기">Condition</button>
      <button data-type="Output" title="결과 출력">Output</button>
      <button data-type="Custom" title="사용자 정의 코드">Custom</button>
    </div>
    
    <div class="sidebar-actions" style="margin-top: 20px;">
      <button id="clearButton" style="background-color: #f44336; color: white;" title="모든 노드 삭제">
        Clear All
      </button>
      <button id="importButton" style="background-color: #4CAF50; color: white; margin-top: 10px;" title="JSON 파일 가져오기">
        Import JSON
      </button>
      <input type="file" id="importInput" style="display: none;" accept=".json">
      <button id="helpButton" style="background-color: #2196F3; color: white;" title="도움말 보기">
        도움말
      </button>
    </div>
  </div>

  <!-- 에디터 -->
  <div class="editor-container">
    <div id="drawflow" class="editor-background"></div>
    
    <!-- 툴팁 -->
    <div id="tooltip" class="tooltip"></div>
  </div>

  <!-- 코드 뷰어 -->
  <div class="code-viewer">
    <div id="formPopup" class="code-viewer-edit">
      <h4>노드 속성</h4>
      <div id="formFields">
        <p>편집할 노드를 선택하세요</p>
      </div>
    </div>

    <div class="code-viewer-content">
      <h3>생성된 Python 코드</h3>
      <pre id="codeOutput" class="language-python"># 블록을 추가해보세요</pre>
      <div class="code-viewer-actions">
        <button onclick="exportJson()">JSON 저장</button>
        <button onclick="copyCode()" class="secondary">코드 복사</button>
        <button onclick="previewExecution()" class="primary" style="background-color: #9C27B0;">실행 미리보기</button>
      </div>
    </div>
  </div>
</div>

<!-- 모달 -->
<div id="helpModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>LangGraph 노드 에디터 도움말</h2>
      <button class="close-button" onclick="closeModal()">&times;</button>
    </div>
    <div class="modal-body">
      <h3>기본 사용법</h3>
      <p>1. 왼쪽 사이드바에서 원하는 노드 유형을 클릭하여 캔버스에 추가합니다.</p>
      <p>2. 노드를 클릭하여 선택하면 오른쪽 패널에서 속성을 편집할 수 있습니다.</p>
      <p>3. 노드의 출력 핀에서 다른 노드의 입력 핀으로 드래그하여 연결할 수 있습니다.</p>
      <p>4. 오른쪽 패널 하단에서 생성된 Python 코드를 확인할 수 있습니다.</p>
      
      <h3>노드 유형</h3>
      <ul>
        <li><strong>Start</strong>: 그래프의 시작점입니다.</li>
        <li><strong>End</strong>: 그래프의 종료점입니다.</li>
        <li><strong>LLM</strong>: 언어 모델을 호출합니다.</li>
        <li><strong>Tool</strong>: 외부 도구를 호출합니다.</li>
        <li><strong>Condition</strong>: 조건에 따라 흐름을 분기합니다.</li>
        <li><strong>Output</strong>: 결과를 출력합니다.</li>
        <li><strong>Custom</strong>: 사용자 정의 Python 코드를 실행합니다.</li>
      </ul>
    </div>
  </div>
</div>

<!-- 스크립트 -->
<script src="https://cdn.jsdelivr.net/npm/drawflow/dist/drawflow.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/toastify-js/1.12.0/toastify.min.js"></script>

<script>
// 네임스페이스 생성
const LangGraph = {
  editor: null,
  nodeCount: 0,
  selectedNodeId: null,
  
  // 노드 타입별 기본 데이터
  nodeTemplates: {
    Start: { 
      label: 'Start',
      html: '<div class="title-box">Start</div><div class="description-box">그래프 시작점</div>',
      data: {}
    },
    End: { 
      label: 'End',
      html: '<div class="title-box">End</div><div class="description-box">그래프 종료점</div>',
      data: {}
    },
    LLM: { 
      label: 'LLM',
      html: '<div class="title-box">LLM</div><div class="description-box">언어 모델 호출</div>',
      data: { model: 'gpt-4', prompt: 'Your prompt here' }
    },
    Tool: { 
      label: 'Tool',
      html: '<div class="title-box">Tool</div><div class="description-box">외부 도구 호출</div>',
      data: { tool_name: 'search_tool', description: 'Searches for information' }
    },
    Condition: { 
      label: 'Condition',
      html: '<div class="title-box">Condition</div><div class="description-box">조건 분기</div>',
      data: { 
        condition: 'result.success == True',
        branches: ['true_branch', 'false_branch'] 
      }
    },
    Output: { 
      label: 'Output',
      html: '<div class="title-box">Output</div><div class="description-box">결과 출력</div>',
      data: {}
    },
    Custom: { 
      label: 'Custom',
      html: '<div class="title-box">Custom</div><div class="description-box">사용자 정의 코드</div>',
      data: { code: '# Write your own code here\n\n' }
    }
  },
  
  // 초기화
  init: function() {
    // Drawflow 에디터 초기화
    this.editor = new Drawflow(document.getElementById('drawflow'));
    this.editor.start();
    this.editor.editor_mode = 'edit';
    this.editor.zoom_enable = true;
    this.editor.zoom_value = 1;
    this.editor.zoom_max = 1.6;
    this.editor.zoom_min = 0.5;
    
    // 이벤트 리스너 등록
    this.registerEventListeners();
    
    // 노드 버튼 이벤트 등록
    this.initNodeButtons();
    
    // 키보드 이벤트 등록
    this.initKeyboardShortcuts();
    
    // 사용자에게 알림 표시
    this.showToast('LangGraph 노드 에디터가 준비되었습니다', 'success');
  },
  
  // 이벤트 리스너 등록
  registerEventListeners: function() {
    // 노드 관련 이벤트
    this.editor.on('nodeSelected', this.handleNodeSelected.bind(this));
    this.editor.on('nodeUnselected', this.handleNodeUnselected.bind(this));
    this.editor.on('nodeCreated', this.handleNodeCreated.bind(this));
    this.editor.on('nodeRemoved', this.handleNodeRemoved.bind(this));
    
    // 연결 관련 이벤트
    this.editor.on('connectionCreated', this.handleConnectionCreated.bind(this));
    this.editor.on('connectionRemoved', this.handleConnectionRemoved.bind(this));
    
    // 전체 그래프 변경 이벤트
    this.editor.on('zoom', this.handleZoom.bind(this));
  },
  
  // 노드 버튼 초기화
  initNodeButtons: function() {
    const buttons = document.querySelectorAll('#nodeButtons button');
    buttons.forEach(button => {
      button.addEventListener('click', () => {
        this.addNode(button.dataset.type);
      });
      
      // 툴팁 이벤트
      button.addEventListener('mouseover', (e) => {
        this.showTooltip(e.target, e.target.title);
      });
      
      button.addEventListener('mouseout', () => {
        this.hideTooltip();
      });
    });
    
    // Clear 버튼 이벤트
    document.getElementById('clearButton').addEventListener('click', this.confirmClearAll.bind(this));
    // Import 버튼 이벤트
    document.getElementById('importButton').addEventListener('click', () => {
      document.getElementById('importInput').click();
    });
    document.getElementById('helpButton').addEventListener('click', () => {
      LangGraph.openHelpModal();
    });
    document.getElementById('importInput').addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        const file = e.target.files[0];
        const reader = new FileReader();
        
        reader.onload = (event) => {
          try {
            const jsonData = JSON.parse(event.target.result);
            this.editor.import(jsonData);
            this.updateCode();
            this.showToast('JSON 파일을 성공적으로 가져왔습니다', 'success');
          } catch (error) {
            console.error('JSON 가져오기 오류:', error);
            this.showToast('JSON 파일 가져오기에 실패했습니다', 'error');
          }
        };
        
        reader.readAsText(file);
      }
    });
  },
  
  // 키보드 단축키 초기화
  initKeyboardShortcuts: function() {
    document.addEventListener('keydown', (e) => {
      // Delete 키로 선택된 노드 삭제
      if (e.key === 'Delete' && this.selectedNodeId !== null) {
        this.editor.removeNodeId(this.selectedNodeId);
        this.selectedNodeId = null;
        this.updateFormFields();
        this.updateCode();
        this.showToast('노드가 삭제되었습니다', 'info');
      }
      
      // Ctrl+S로 JSON 저장
      if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        this.exportJson();
      }
      
      // Ctrl+C로 코드 복사
      if (e.ctrlKey && e.key === 'c' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
        e.preventDefault();
        this.copyCode();
      }
      
      // F1 또는 ?로 도움말 표시
      if (e.key === 'F1' || (e.shiftKey && e.key === '?')) {
        e.preventDefault();
        this.openHelpModal();
      }
    });
  },
  
  // 노드 추가
  addNode: function(type) {
    try {
      // 노드 위치 계산 (가시 영역 내에 배치)
      const editor = document.getElementById('drawflow');
      const posX = 100 + (this.nodeCount % 3) * 250;
      const posY = 100 + Math.floor(this.nodeCount / 3) * 150;
      
      const template = this.nodeTemplates[type];
      if (!template) {
        throw new Error(`알 수 없는 노드 유형: ${type}`);
      }
      
      // 노드 ID 생성
      const nodeId = this.editor.addNode(
        type,
        1, // 입력 커넥터 수
        1, // 출력 커넥터 수 
        posX,
        posY,
        type,
        { ...template.data, label: template.label },
        template.html
      );
      
      // 노드 클래스 추가 (스타일링 용도)
      setTimeout(() => {
        const nodeElement = document.querySelector(`.drawflow-node[data-id="${nodeId}"]`);
        if (nodeElement) {
          nodeElement.classList.add(type);
        }
      }, 10);
      
      this.nodeCount++;
      this.updateCode();
      this.showToast(`${type} 노드가 추가되었습니다`, 'success');
      
      return nodeId;
    } catch (error) {
      console.error('노드 추가 오류:', error);
      this.showToast('노드를 추가하는 중 오류가 발생했습니다', 'error');
      return null;
    }
  },
  
  // 노드 선택 핸들러
  handleNodeSelected: function(nodeId) {
    this.selectedNodeId = nodeId;
    this.updateFormFields();
    
    // 선택된 노드로 스크롤
    const nodeElement = document.querySelector(`.drawflow-node[data-id="${nodeId}"]`);
    if (nodeElement) {
      nodeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  },
  
  // 노드 선택 해제 핸들러
  handleNodeUnselected: function() {
    this.selectedNodeId = null;
    this.updateFormFields();
  },
  
  // 노드 생성 핸들러
  handleNodeCreated: function() {
    this.updateCode();
  },
  
  // 노드 삭제 핸들러
  handleNodeRemoved: function() {
    this.updateCode();
    if (this.selectedNodeId) {
      this.selectedNodeId = null;
      this.updateFormFields();
    }
  },
  
  // 연결 생성 핸들러
  handleConnectionCreated: function(connection) {
    // 연결 스타일 업데이트
    this.updateConnectionStyle(connection);
    this.updateCode();
    this.showToast('노드가 연결되었습니다', 'info');
    // 연결 유효성 검사 추가
    const sourceNode = this.editor.getNodeFromId(connection.output_id);
    const targetNode = this.editor.getNodeFromId(connection.input_id);
    
    // End 노드는 출력 연결을 가질 수 없음
    if (sourceNode?.name === 'End') {
      this.editor.removeSingleConnection(connection.output_id, connection.input_id, connection.output_class, connection.input_class);
      this.showToast('End 노드는 출력 연결을 가질 수 없습니다', 'error');
      return;
    }
    
    // Start 노드는 입력 연결을 가질 수 없음
    if (targetNode?.name === 'Start') {
      this.editor.removeSingleConnection(connection.output_id, connection.input_id, connection.output_class, connection.input_class);
      this.showToast('Start 노드는 입력 연결을 가질 수 없습니다', 'error');
      return;
    }
    
    // 연결 스타일 업데이트
    this.updateConnectionStyle(connection);
    this.updateCode();
    this.showToast('노드가 연결되었습니다', 'info');
  },
  
  // 연결 삭제 핸들러
  handleConnectionRemoved: function() {
    this.updateCode();
  },
  
  // 줌 핸들러
  handleZoom: function() {
    // 줌 이벤트 처리
  },
  
  // 연결 스타일 업데이트
  updateConnectionStyle: function(connection) {
    try {
      const { input_id, output_id } = connection;
      
      // 조건 노드에서 나오는 연결선 스타일 적용
      setTimeout(() => {
        const sourceNode = this.editor.getNodeFromId(output_id);
        const connections = document.querySelectorAll(`.connection.node_in_${input_id}.node_out_${output_id}`);
        
        connections.forEach(conn => {
          if (sourceNode?.name === 'Condition') {
            conn.classList.add('condition-connection');
            
            // 브랜치별 다른 색상 스타일 적용
            const sourceNodeData = sourceNode.data;
            const branches = sourceNodeData?.branches || ['true_branch', 'false_branch'];
            const connectionIndex = Array.from(
              document.querySelectorAll(`.connection.node_out_${output_id}`)
            ).indexOf(conn);
            
            if (connectionIndex >= 0 && connectionIndex < branches.length) {
              // 브랜치별 다른 스타일 적용
              conn.style.setProperty('--branch-color', this.getBranchColor(connectionIndex));
            }
          }
        });
      }, 100);
    } catch (error) {
      console.error('연결 스타일 업데이트 오류:', error);
    }
  },

// 브랜치별 색상 반환
getBranchColor: function(index) {
  const colors = [
    '#4CAF50', // 녹색 (true)  
    '#F44336', // 빨강 (false)
    '#2196F3', // 파랑
    '#FF9800', // 주황
    '#9C27B0', // 보라
    '#00BCD4'  // 청록
  ];
  return colors[index % colors.length];
},
  // 폼 필드 업데이트
  updateFormFields: function() {
    const formFields = document.getElementById('formFields');
    
    if (!this.selectedNodeId) {
      formFields.innerHTML = '<p>편집할 노드를 선택하세요</p>';
      return;
    }
    
    try {
      const node = this.editor.getNodeFromId(this.selectedNodeId);
      if (!node) {
        throw new Error('선택된 노드를 찾을 수 없습니다');
      }
      
      const data = node.data || {};
      let fieldsHtml = `
        <label>
          블록 이름
          <input id="nodeLabel" value="${data.label || node.name || ''}" placeholder="노드 이름">
        </label>
      `;
      
      // 노드 타입별 필드 추가
      switch (node.name) {
        case 'LLM':
          fieldsHtml += `
            <label>
              모델
              <input id="nodeModel" value="${data.model || ''}" placeholder="예: gpt-4">
            </label>
            <label>
              프롬프트
              <textarea id="nodePrompt" placeholder="언어 모델에 전달할 프롬프트">${data.prompt || ''}</textarea>
            </label>
          `;
          break;
        case 'Tool':
          fieldsHtml += `
            <label>
              도구 이름
              <input id="nodeToolName" value="${data.tool_name || ''}" placeholder="예: search_tool">
            </label>
            <label>
              설명
              <textarea id="nodeDescription" placeholder="도구에 대한 설명">${data.description || ''}</textarea>
            </label>
          `;
          break;
        case 'Condition':
          fieldsHtml += `
            <label>
              조건식
              <input id="nodeCondition" value="${data.condition || ''}" placeholder="예: result.success == True">
            </label>
            <div id="branchContainer">
              <label>브랜치</label>
              ${(data.branches || ['true_branch', 'false_branch']).map((branch, index) => `
                <div class="branch-item" style="display: flex; margin-bottom: 8px;">
                  <input id="branch_${index}" value="${branch}" placeholder="브랜치 이름" style="flex: 1; margin-right: 8px;">
                  <button type="button" onclick="LangGraph.removeBranch(${index})" style="background: #f44336; color: white;">-</button>
                </div>
              `).join('')}
              <button type="button" onclick="LangGraph.addBranch()" style="width: 100%; margin-top: 8px; background: #4CAF50; color: white;">+ 브랜치 추가</button>
            </div>
          `;
          break;
        case 'Custom':
          fieldsHtml += `
            <label>
              사용자 정의 코드
              <textarea id="nodeCode" placeholder="Python 코드 작성" style="min-height: 120px;">${data.code || ''}</textarea>
            </label>
          `;
          break;
      }
      
      fieldsHtml += `<button onclick="LangGraph.saveNodeForm()">변경사항 저장</button>`;
      formFields.innerHTML = fieldsHtml;
    } catch (error) {
      console.error('폼 필드 업데이트 오류:', error);
      formFields.innerHTML = '<p>노드 정보를 불러올 수 없습니다</p>';
    }
  },
  
  // 노드 폼 저장
  saveNodeForm: function() {
    if (!this.selectedNodeId) {
      this.showToast('선택된 노드가 없습니다', 'error');
      return;
    }
    
    try {
      // 기본 필드
      const newData = {};
      const labelInput = document.getElementById('nodeLabel');
      if (labelInput) newData.label = labelInput.value || 'Unnamed Node'; // 기본값 제공
      
      // 노드 유형별 필드
      const node = this.editor.getNodeFromId(this.selectedNodeId);
      switch (node.name) {
        case 'LLM':
          const modelInput = document.getElementById('nodeModel');
          const promptInput = document.getElementById('nodePrompt');
          
          // 필수 필드 검증
          if (!modelInput?.value) {
            this.showToast('모델 이름은 필수입니다', 'error');
            return;
          }
          
          newData.model = modelInput.value;
          newData.prompt = promptInput?.value || '';
          break;
          
        case 'Tool':
          const toolNameInput = document.getElementById('nodeToolName');
          
          // 필수 필드 검증
          if (!toolNameInput?.value) {
            this.showToast('도구 이름은 필수입니다', 'error');
            return;
          }
          
          newData.tool_name = toolNameInput.value;
          newData.description = document.getElementById('nodeDescription')?.value || '';
          break;
          
        case 'Condition':
          const conditionInput = document.getElementById('nodeCondition');
          if (conditionInput) newData.condition = conditionInput.value;
          
          // 브랜치 데이터 수집
          const branches = [];
          let index = 0;
          let branchInput = document.getElementById(`branch_${index}`);
          while (branchInput) {
            if (branchInput.value.trim()) {
              branches.push(branchInput.value.trim());
            }
            index++;
            branchInput = document.getElementById(`branch_${index}`);
          }
          
          // 최소 2개의 브랜치 보장
          if (branches.length < 2) {
            branches.push('true_branch', 'false_branch');
          }
          
          newData.branches = branches;
          break;
          
        case 'Custom':
          const codeInput = document.getElementById('nodeCode');
          if (codeInput) newData.code = codeInput.value;
          break;
      }
      
      // 노드 데이터 업데이트
      this.editor.updateNodeDataFromId(this.selectedNodeId, newData);
      
      // 노드 UI 업데이트
      this.updateNodeUI(this.selectedNodeId, newData);
      
      // 코드 재생성
      this.updateCode();
      
      this.showToast('노드가 업데이트되었습니다', 'success');
    } catch (error) {
      console.error('노드 저장 오류:', error);
      this.showToast('노드 업데이트 중 오류가 발생했습니다', 'error');
    }
  },
  
   // 노드 UI 업데이트
  updateNodeUI: function(nodeId, data) {
    try {
      const node = this.editor.getNodeFromId(nodeId);
      if (!node) return;
      
      // 노드 데이터 및 HTML 업데이트
      if (data.label) {
        // HTML 내용 생성
        const html = `<div class="title-box">${data.label}</div><div class="description-box">${this.getNodeDescription(node.name, data)}</div>`;
        
        // 노드 HTML 업데이트 (내부 데이터)
        node.html = html;
        
        // DOM에 직접 반영 - 정확한 셀렉터로 요소 찾기
        const nodeElement = document.querySelector(`#node-${nodeId} .drawflow_content_node`);
        if (nodeElement) {
          nodeElement.innerHTML = html;
        } else {
          // 대체 셀렉터 시도
          const altNodeElement = document.querySelector(`.drawflow-node[data-id="${nodeId}"] .drawflow_content_node`);
          if (altNodeElement) {
            altNodeElement.innerHTML = html;
          } else {
            console.warn(`노드 요소를 찾을 수 없음: ${nodeId}`);
          }
        }
      }
    } catch (error) {
      console.error('노드 UI 업데이트 오류:', error);
    }
  },
  
  // 노드 설명 반환
  getNodeDescription: function(nodeType, data) {
    switch (nodeType) {
      case 'Start': return '그래프 시작점';
      case 'End': return '그래프 종료점';
      case 'LLM': return data.model ? `Model: ${data.model}` : '언어 모델 호출';
      case 'Tool': return data.tool_name ? `Tool: ${data.tool_name}` : '외부 도구 호출';
      case 'Condition': return data.condition ? `If: ${data.condition}` : '조건 분기';
      case 'Output': return '결과 출력';
      case 'Custom': return '사용자 정의 코드';
      default: return '';
    }
  },
  

  // 브랜치 추가
  addBranch: function() {
    const branchContainer = document.getElementById('branchContainer');
    if (!branchContainer) return;
    
    const branchItems = branchContainer.querySelectorAll('.branch-item');
    const newIndex = branchItems.length;
    
    const newBranchDiv = document.createElement('div');
    newBranchDiv.className = 'branch-item';
    newBranchDiv.style = 'display: flex; margin-bottom: 8px;';
    newBranchDiv.innerHTML = `
      <input id="branch_${newIndex}" placeholder="브랜치 이름" style="flex: 1; margin-right: 8px;">
      <button type="button" onclick="LangGraph.removeBranch(${newIndex})" style="background: #f44336; color: white;">-</button>
    `;
    
    // 버튼 앞에 삽입
    const addButton = branchContainer.querySelector('button[onclick="LangGraph.addBranch()"]');
    branchContainer.insertBefore(newBranchDiv, addButton);
  },

  // 브랜치 제거
  removeBranch: function(index) {
    const branchItem = document.getElementById(`branch_${index}`).parentNode;
    if (branchItem) {
      branchItem.remove();
      
      // 인덱스 재정렬
      this.reindexBranches();
    }
  },

  // 브랜치 인덱스 재정렬
  reindexBranches: function() {
    const branchContainer = document.getElementById('branchContainer');
    if (!branchContainer) return;
    
    const branchItems = branchContainer.querySelectorAll('.branch-item');
    branchItems.forEach((item, i) => {
      const input = item.querySelector('input');
      const button = item.querySelector('button');
      
      input.id = `branch_${i}`;
      button.setAttribute('onclick', `LangGraph.removeBranch(${i})`);
    });
  },


  // 코드 생성
  updateCode: function() {
    try {
      const data = this.editor.export();
      if (!data.drawflow || !data.drawflow.Home || !data.drawflow.Home.data) {
        document.getElementById('codeOutput').textContent = '# 블록을 추가해보세요';
        Prism.highlightElement(document.getElementById('codeOutput'));
        return;
      }
      
      const graph = data.drawflow.Home.data;
      
      // 노드 간 연결 정보 수집
      const edges = Object.fromEntries(
        Object.entries(graph).map(([id, node]) => [
          id, 
          node.outputs?.output_1?.connections.map(c => c.node.toString()) || []
        ])
      );
      
      const visited = new Set();
      const codeLines = [
        '# LangGraph 자동 생성 코드',
        'from typing import Dict, List, Any',
        'from langchain_core.language_models import ChatOpenAI',
        'from langchain.tools import tool',
        'from langgraph.graph import StateGraph, END',
        '',
        '# 상태 정의',
        'class State(dict):',
        '    """그래프 상태 객체"""',
        '    def __init__(self, **kwargs):',
        '        super().__init__(**kwargs)',
        '        for key, value in kwargs.items():',
        '            setattr(self, key, value)',
        '',
        '# 그래프 생성',
        'def create_graph():',
        '    """LangGraph 워크플로우 생성"""',
        '    graph = StateGraph(State)',
        ''
      ];
      
      // 노드 방문 함수
      const processNode = (nodeId) => {
        if (visited.has(nodeId)) return;
        visited.add(nodeId);
        
        const node = graph[nodeId];
        if (!node) return;
        
        const nodeName = (node.data.label || node.name).toLowerCase().replace(/\s+/g, '_');
        
        switch (node.name) {
          case 'Start':
            codeLines.push('    # 시작 노드');
            codeLines.push(`    # ${node.data.label || 'Start'}`);
            break;
            
          case 'End':
            codeLines.push('    # 종료 노드');
            codeLines.push(`    # ${node.data.label || 'End'}`);
            codeLines.push('    graph.add_node("end", END)');
            break;
            
          case 'LLM':
            codeLines.push(`    # LLM 노드: ${node.data.label || 'LLM'}`);
            codeLines.push(`    def ${nodeName}_node(state):`);
            codeLines.push(`        """${node.data.label || 'LLM 호출'}"""`);
            codeLines.push(`        llm = ChatOpenAI(model='${node.data.model || 'gpt-4'}')`);
            codeLines.push(`        response = llm.invoke("${node.data.prompt?.replace(/"/g, '\\"') || 'Your prompt here'}")`);
            codeLines.push('        return {"response": response}');
            codeLines.push('');
            codeLines.push(`    graph.add_node("${nodeName}", ${nodeName}_node)`);
            break;
            
          case 'Tool':
            codeLines.push(`    # Tool 노드: ${node.data.label || 'Tool'}`);
            codeLines.push('    @tool');
            codeLines.push(`    def ${node.data.tool_name || 'tool_function'}(query: str) -> str:`);
            codeLines.push(`        """${node.data.description || 'Tool description'}"""`);
            codeLines.push('        # 도구 구현');
            codeLines.push('        return f"Result for {query}"');
            codeLines.push('');
            codeLines.push(`    def ${nodeName}_node(state):`);
            codeLines.push(`        result = ${node.data.tool_name || 'tool_function'}(state.get("query", ""))`);
            codeLines.push('        return {"tool_result": result}');
            codeLines.push('');
            codeLines.push(`    graph.add_node("${nodeName}", ${nodeName}_node)`);
            break;
            
          case 'Condition':
            codeLines.push(`    # Condition 노드: ${node.data.label || 'Condition'}`);
            codeLines.push(`    def ${nodeName}_router(state):`);
            codeLines.push(`        """${node.data.label || 'Condition'} 라우터"""`);;
                      
            // 조건식 기반 분기 코드 생성
            const branches = node.data.branches || ['true_branch', 'false_branch'];
            const nextNodes = edges[nodeId] || [];
            
            if (branches.length === 2 && nextNodes.length > 0) {
              // 기본 true/false 분기
              codeLines.push(`        if ${node.data.condition || 'True'}:`);
              codeLines.push(`            return "${branches[0]}"`);
              codeLines.push('        else:');
              codeLines.push(`            return "${branches[1]}"`);
            } else if (branches.length > 0 && nextNodes.length > 0) {
              // 다중 분기
              codeLines.push('        # 조건에 따라 분기 선택');
              codeLines.push(`        condition = ${node.data.condition || 'None'}`);
              codeLines.push('        # 분기 결정 로직');
              branches.forEach((branch, i) => {
                if (i === 0) {
                  codeLines.push(`        if condition == ${i}:`);
                } else if (i === branches.length - 1) {
                  codeLines.push('        else:');
                } else {
                  codeLines.push(`        elif condition == ${i}:`);
                }
                codeLines.push(`            return "${branch}"`);
              });
            } else {
              codeLines.push('        # 연결된 브랜치가 없습니다');
              codeLines.push('        return None');
            }
            
            codeLines.push('');
            codeLines.push(`    graph.add_conditional_edges(`);
            codeLines.push(`        "${nodeName}",`);
            codeLines.push(`        ${nodeName}_router,`);
            codeLines.push('        {');
            
            // 브랜치별 목적지 매핑 - 실제 연결 정보와 매핑
            const branchMappings = [];
            branches.forEach((branch, idx) => {
              if (idx < nextNodes.length) {
                const targetNode = graph[nextNodes[idx]];
                if (targetNode) {
                  const targetName = (targetNode.data.label || targetNode.name).toLowerCase().replace(/\s+/g, '_');
                  branchMappings.push(`            "${branch}": "${targetName}"`);
                }
              }
            });
            
            codeLines.push(branchMappings.join(',\n') || '            # No connections');
            codeLines.push('        }');
            codeLines.push('    )');
            break;
            
          case 'Output':
            codeLines.push(`    # Output 노드: ${node.data.label || 'Output'}`);
            codeLines.push(`    def ${nodeName}_node(state):`);
            codeLines.push('        """결과 출력"""');
            codeLines.push('        print(f"Output: {state.get(\'response\', \'No response\')}")')
            codeLines.push('        return state');
            codeLines.push('');
            codeLines.push(`    graph.add_node("${nodeName}", ${nodeName}_node)`);
            break;
            
          case 'Custom':
            codeLines.push(`    # Custom 노드: ${node.data.label || 'Custom'}`);
            codeLines.push(`    def ${nodeName}_node(state):`);
            const customCode = node.data.code?.trim() || '# Custom code';
            // 들여쓰기 처리
            customCode.split('\n').forEach(line => {
              codeLines.push(`        ${line}`);
            });
            codeLines.push('        return state');
            codeLines.push('');
            codeLines.push(`    graph.add_node("${nodeName}", ${nodeName}_node)`);
            break;
        }
        
        // 다음 노드 처리
        edges[nodeId].forEach(nextNodeId => {
          processNode(nextNodeId);
        });
      };
      
      // 시작 노드 찾기 및 처리
      let startNode = null;
      Object.entries(graph).forEach(([id, node]) => {
        if (node.name === 'Start') {
          startNode = id;
        }
      });
      
      // 시작 노드부터 DFS 수행
      if (startNode) {
        processNode(startNode);
      } else {
        // 시작 노드가 없으면 모든 노드 처리
        Object.keys(graph).forEach(processNode);
      }
      
      // 엣지 연결 코드 생성
      codeLines.push('    # 노드 연결');
      Object.entries(edges).forEach(([nodeId, targets]) => {
        const sourceNode = graph[nodeId];
        if (!sourceNode) return;
        
        const sourceName = (sourceNode.data.label || sourceNode.name).toLowerCase().replace(/\s+/g, '_');
        
        targets.forEach(targetId => {
          const targetNode = graph[targetId];
          if (!targetNode) return;
          
          const targetName = (targetNode.data.label || targetNode.name).toLowerCase().replace(/\s+/g, '_');
          
          // Condition 노드는 이미 처리했으므로 건너뜀
          if (sourceNode.name !== 'Condition') {
            codeLines.push(`    graph.add_edge("${sourceName}", "${targetName}")`);
          }
        });
      });
      
      // 그래프 실행 코드
      codeLines.push('');
      codeLines.push('    return graph');
      codeLines.push('');
      codeLines.push('# 그래프 실행');
      codeLines.push('if __name__ == "__main__":');
      codeLines.push('    graph = create_graph()');
      codeLines.push('    # 초기 상태 설정');
      codeLines.push('    initial_state = State(query="한국의 수도는 어디인가요?")');
      codeLines.push('    # 그래프 실행');
      codeLines.push('    graph.invoke(initial_state)');
      
      // 코드 표시
      const finalCode = codeLines.join('\n');
      document.getElementById('codeOutput').textContent = finalCode;
      Prism.highlightElement(document.getElementById('codeOutput'));
    } catch (error) {
      console.error('코드 생성 오류:', error);
      document.getElementById('codeOutput').textContent = `# 오류 발생: ${error.message}`;
      Prism.highlightElement(document.getElementById('codeOutput'));
      this.showToast('코드 생성 중 오류가 발생했습니다', 'error');
    }
  },
  
  // JSON 내보내기
  exportJson: function() {
    try {
      const dataStr = JSON.stringify(this.editor.export(), null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'langgraph_flow.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      this.showToast('JSON 파일이 저장되었습니다', 'success');
    } catch (error) {
      console.error('JSON 내보내기 오류:', error);
      this.showToast('JSON 내보내기 중 오류가 발생했습니다', 'error');
    }
  },
  
  // 코드 복사
  copyCode: function() {
    try {
      const codeOutput = document.getElementById('codeOutput');
      const tempTextarea = document.createElement('textarea');
      tempTextarea.value = codeOutput.textContent;
      document.body.appendChild(tempTextarea);
      tempTextarea.select();
      document.execCommand('copy');
      document.body.removeChild(tempTextarea);
      
      this.showToast('코드가 클립보드에 복사되었습니다', 'success');
    } catch (error) {
      console.error('코드 복사 오류:', error);
      this.showToast('코드 복사 중 오류가 발생했습니다', 'error');
    }
  },
  
  // 모든 노드 삭제 확인
  confirmClearAll: function() {
    if (confirm('모든 노드를 삭제하시겠습니까?')) {
      this.editor.clear();
      this.nodeCount = 0;
      this.selectedNodeId = null;
      this.updateFormFields();
      this.updateCode();
      this.showToast('모든 노드가 삭제되었습니다', 'info');
    }
  },
  
  // 툴팁 표시
  showTooltip: function(element, text) {
    const tooltip = document.getElementById('tooltip');
    const rect = element.getBoundingClientRect();
    
    tooltip.textContent = text;
    tooltip.style.left = `${rect.left + rect.width / 2 - tooltip.offsetWidth / 2}px`;
    tooltip.style.top = `${rect.bottom + 5}px`;
    tooltip.style.opacity = '1';
  },
  
  // 툴팁 숨기기
  hideTooltip: function() {
    const tooltip = document.getElementById('tooltip');
    tooltip.style.opacity = '0';
  },
  
  // 도움말 모달 열기
  openHelpModal: function() {
    const modal = document.getElementById('helpModal');
    modal.style.display = 'flex';
  },
  
  // 모달 닫기
  closeModal: function() {
    const modals = document.querySelectorAll('.modal');
    modals.forEach(modal => {
      modal.style.display = 'none';
    });
  },
  
  //미리보기 실행
  previewExecution: function() {
  const data = this.editor.export();
  if (!data.drawflow?.Home?.data) {
    this.showToast('미리보기할 그래프가 없습니다', 'error');
    return;
  }
  
  const graph = data.drawflow.Home.data;
  
  // 시작 노드 찾기
  let startNodeId = null;
  Object.entries(graph).forEach(([id, node]) => {
    if (node.name === 'Start') {
      startNodeId = id;
    }
  });
  
  if (!startNodeId) {
    this.showToast('시작 노드가 필요합니다', 'error');
    return;
  }
  
  // 실행 흐름 결과를 보여주는 모달 생성
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.display = 'flex';
  
  const modalContent = document.createElement('div');
  modalContent.className = 'modal-content';
  modalContent.style.width = '80%';
  modalContent.style.maxWidth = '800px';
  
  const header = document.createElement('div');
  header.className = 'modal-header';
  header.innerHTML = `
    <h2>실행 흐름 미리보기</h2>
    <button class="close-button" onclick="LangGraph.closeModal()">&times;</button>
  `;
  
  const body = document.createElement('div');
  body.className = 'modal-body';
  body.innerHTML = '<div id="execution-preview" style="max-height: 400px; overflow-y: auto;"></div>';
  
  modalContent.appendChild(header);
  modalContent.appendChild(body);
  modal.appendChild(modalContent);
  document.body.appendChild(modal);
  
  // 실행 흐름 시뮬레이션 및 표시
  this.simulateExecution(startNodeId, graph, document.getElementById('execution-preview'));
},

simulateExecution: function(nodeId, graph, container) {
  const visited = new Set();
  const state = { query: "한국의 수도는 어디인가요?" };
  
  const simulateNode = (id, depth = 0) => {
    if (visited.has(id)) return;
    visited.add(id);
    
    const node = graph[id];
    if (!node) return;
    
    const nodeDiv = document.createElement('div');
    nodeDiv.style.marginLeft = `${depth * 20}px`;
    nodeDiv.style.padding = '10px';
    nodeDiv.style.marginBottom = '10px';
    nodeDiv.style.borderLeft = '2px solid #2196F3';
    nodeDiv.style.backgroundColor = '#f5f5f5';
    nodeDiv.style.borderRadius = '4px';
    
    // 노드 메타데이터 표시
    const nodeLabel = node.data.label || node.name;
    nodeDiv.innerHTML = `<h4 style="margin: 0 0 10px 0;">${nodeLabel} (${node.name})</h4>`;
    
    // 노드 유형별 동작 시뮬레이션
    switch (node.name) {
      case 'Start':
        nodeDiv.innerHTML += `<p>초기 상태: ${JSON.stringify(state)}</p>`;
        break;
        
      case 'End':
        nodeDiv.innerHTML += `<p>실행 종료, 최종 상태: ${JSON.stringify(state)}</p>`;
        break;
        
      case 'LLM':
        const response = '이는 LLM 응답의 시뮬레이션입니다. 실제 응답은 다를 수 있습니다.';
        state.response = response;
        nodeDiv.innerHTML += `<p>프롬프트: ${node.data.prompt || '지정되지 않음'}</p>`;
        nodeDiv.innerHTML += `<p>응답: ${response}</p>`;
        break;
        
      case 'Tool':
        const result = `${node.data.tool_name || 'tool'} 실행 결과`;
        state.tool_result = result;
        nodeDiv.innerHTML += `<p>도구: ${node.data.tool_name || '지정되지 않음'}</p>`;
        nodeDiv.innerHTML += `<p>결과: ${result}</p>`;
        break;
        
      case 'Condition':
        const condition = node.data.condition || 'True';
        const branches = node.data.branches || ['true_branch', 'false_branch'];
        nodeDiv.innerHTML += `<p>조건식: ${condition}</p>`;
        nodeDiv.innerHTML += `<p>선택된 브랜치: ${branches[0]}</p>`;
        break;
        
      case 'Output':
        nodeDiv.innerHTML += `<p>출력: ${state.response || state.tool_result || '결과 없음'}</p>`;
        break;
        
      case 'Custom':
        nodeDiv.innerHTML += `<p>사용자 정의 코드 실행</p>`;
        nodeDiv.innerHTML += `<pre style="background: #f0f0f0; padding: 5px;">${node.data.code || '# 코드 없음'}</pre>`;
        break;
    }
    
    container.appendChild(nodeDiv);
    
    // 다음 노드 처리
    const outputs = node.outputs?.output_1?.connections || [];
    
    // Condition 노드의 경우 첫 번째 분기만 시뮬레이션
    if (node.name === 'Condition' && outputs.length > 0) {
      const nextNode = outputs[0].node;
      simulateNode(nextNode, depth + 1);
    } else {
      // 일반 노드는 모든 연결 시뮬레이션
      outputs.forEach(conn => {
        simulateNode(conn.node, depth + 1);
      });
    }
  };
  
  simulateNode(nodeId);
},


  // 알림 표시
  showToast: function(message, type = 'info') {
    const bgColors = {
      success: 'linear-gradient(to right, #00b09b, #96c93d)',
      error: 'linear-gradient(to right, #ff5f6d, #ffc371)',
      info: 'linear-gradient(to right, #2193b0, #6dd5ed)',
      warning: 'linear-gradient(to right, #f2994a, #f2c94c)'
    };
    
    Toastify({
      text: message,
      duration: 3000,
      gravity: 'bottom',
      position: 'right',
      backgroundColor: bgColors[type] || bgColors.info,
      stopOnFocus: true
    }).showToast();
  }
};

// 초기화
document.addEventListener('DOMContentLoaded', () => {
  LangGraph.init();
  
  // 모달 외부 클릭시 닫기
  window.addEventListener('click', (e) => {
    const modals = document.querySelectorAll('.modal');
    modals.forEach(modal => {
      if (e.target === modal) {
        modal.style.display = 'none';
      }
    });
  });
});


// 전역 함수 노출
window.exportJson = function() { LangGraph.exportJson(); };
window.copyCode = function() { LangGraph.copyCode(); };
window.closeModal = function() { LangGraph.closeModal(); };
window.previewExecution = function() {LangGraph.previewExecution(); };


</script>

</body>
</html>